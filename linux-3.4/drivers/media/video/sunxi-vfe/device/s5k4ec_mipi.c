/*
 * A V4L2 driver for samsung s5k4ec cameras.
 *
 */
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <linux/clk.h>
#include <media/v4l2-device.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-mediabus.h>
#include <linux/io.h>


#include "camera.h"


MODULE_AUTHOR ("raymonxiu");
MODULE_DESCRIPTION ("A low-level driver for samsung s5k4ec mipi sensors");
MODULE_LICENSE ("GPL");

#define DEV_DBG_EN      1
#if(DEV_DBG_EN == 1)
#define vfe_dev_dbg(x,arg...) printk("[S5K4EC_MIPI]"x,##arg)
#else
#define vfe_dev_dbg(x,arg...)
#endif
#define vfe_dev_err(x,arg...) printk("[S5K4EC_MIPI]"x,##arg)
#define vfe_dev_print(x,arg...) printk("[S5K4EC_MIPI]"x,##arg)

#define LOG_ERR_RET(x)  { \
    int ret;  \
    ret = x; \
    if(ret < 0) {\
      vfe_dev_err("error at %s\n",__func__);  \
      return ret; \
    } \
  }

#define MCLK              (24*1000*1000)
#define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_HIGH
#define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_RISING
#define V4L2_IDENT_SENSOR 0x4ec

#define CSI_STBY_ON     0
#define CSI_STBY_OFF    1
#define CSI_RST_ON      0
#define CSI_RST_OFF     1
#define CSI_PWR_ON      1
#define CSI_PWR_OFF     0
#define CSI_AF_PWR_ON   0
#define CSI_AF_PWR_OFF  1

#define regval_list reg_list_a16_d16

#define REG_TERM 0xfffe
#define VAL_TERM 0xfe
#define REG_DLY  0xffff

#define CONTINUEOUS_AF

#define AF_WIN_NEW_COORD

unsigned int coarse_af_pd = 0;

/*
 * Our nominal (default) frame rate.
 */
#define SENSOR_FRAME_RATE 30

/*
 * The s5k4ec sits on i2c with ID 0x5a
 */
#define I2C_ADDR 0x5a
#define SENSOR_NAME "s5k4ec_mipi"
/* Registers */


static int sensor_s_band_filter (struct v4l2_subdev * sd,
                                 enum v4l2_power_line_frequency value);


/*
 * Information we maintain about a known sensor.
 */
struct sensor_format_struct;  /* coming later */

struct cfg_array { /* coming later */
  struct regval_list * regs;
  int size;
};

static inline struct sensor_info * to_state (struct v4l2_subdev * sd)
{
  return container_of (sd, struct sensor_info, sd);
}


/*
 * The default register settings
 *
 */

static struct regval_list sensor_default_regs[] = {


  {0xFCFC, 0xD000},
  {0x0010, 0x0001},
  {0x1030, 0x0000},
  {0x0014, 0x0001},
  




  {0x002A,  0x1082},
  {0x0F12,  0x0000}, 
  {0x0F12,  0x0000}, 
  {0x002A,  0x1088},
  {0x0F12,  0x0000}, 
  


  {0x0028, 0xD000},
  {0x002A, 0x007A},
  {0x0f12, 0x0000},
  {0x002A, 0xE406}, 
  {0x0F12, 0x0092},
  {0x002A, 0xE410},
  {0x0F12, 0x3804}, 
  {0x002A, 0xE41A},
  {0x0F12, 0x0010},
  {0x002A, 0xE420},
  {0x0F12, 0x0003}, 
  {0x0F12, 0x0060}, 
  {0x002A, 0xE42E},
  {0x0F12, 0x0004}, 
  {0x002A, 0xF400},
  {0x0F12, 0x5A3C}, 
  {0x0F12, 0x0023}, 
  {0x0F12, 0x8080}, 
  {0x0F12, 0x03AF}, 
  {0x0F12, 0x000A}, 
  {0x0F12, 0xAA54}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x464E}, 
  {0x0F12, 0x0240}, 
  {0x0F12, 0x0240}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x1000}, 
  {0x0F12, 0x55cc}, 
  {0x0F12, 0xD000}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0202}, 
  {0x0F12, 0x0401}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0x0088}, 
  {0x0F12, 0x009F}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x1800}, 
  {0x0F12, 0x0088}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2428}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x03EE}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x002A, 0xF552},
  {0x0F12, 0x0708}, 
  {0x0F12, 0x080C}, 
  

  {0x0028, 0x7000},
  {0x002A, 0x18BC},
  {0x0F12, 0x0004},
  {0x0F12, 0x05B6},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x0F12, 0x05BA},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0007},
  {0x0F12, 0x05BA},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x01F4},
  {0x0F12, 0x024E},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x01F4},
  {0x0F12, 0x05B6},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x01F4},
  {0x0F12, 0x05BA},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x01F4},
  {0x0F12, 0x024F},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0075},
  {0x0F12, 0x00CF},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0075},
  {0x0F12, 0x00D6},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0004},
  {0x0F12, 0x01F4},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x00F0},
  {0x0F12, 0x01F4},
  {0x0F12, 0x029E},
  {0x0F12, 0x05B2},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x01F8},
  {0x0F12, 0x0228},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0208},
  {0x0F12, 0x0238},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0218},
  {0x0F12, 0x0238},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x0F12, 0x0009},
  {0x0F12, 0x00DE},
  {0x0F12, 0x05C0},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x00DF},
  {0x0F12, 0x00E4},
  {0x0F12, 0x01F8},
  {0x0F12, 0x01FD},
  {0x0F12, 0x05B6},
  {0x0F12, 0x05BB},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x01F8},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0077},
  {0x0F12, 0x007E},
  {0x0F12, 0x024F},
  {0x0F12, 0x025E},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  

  {0x0F12, 0x0004},
  {0x0F12, 0x09D1},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x0F12, 0x09D5},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0008},
  {0x0F12, 0x09D5},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x02AA},
  {0x0F12, 0x0326},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x02AA},
  {0x0F12, 0x09D1},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x02AA},
  {0x0F12, 0x09D5},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x02AA},
  {0x0F12, 0x0327},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0008},
  {0x0F12, 0x0084},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0008},
  {0x0F12, 0x008D},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0008},
  {0x0F12, 0x02AA},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x00AA},
  {0x0F12, 0x02AA},
  {0x0F12, 0x03AD},
  {0x0F12, 0x09CD},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x02AE},
  {0x0F12, 0x02DE},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x02BE},
  {0x0F12, 0x02EE},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x02CE},
  {0x0F12, 0x02EE},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x0F12, 0x0009},
  {0x0F12, 0x0095},
  {0x0F12, 0x09DB},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0096},
  {0x0F12, 0x009B},
  {0x0F12, 0x02AE},
  {0x0F12, 0x02B3},
  {0x0F12, 0x09D1},
  {0x0F12, 0x09D6},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x02AE},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0009},
  {0x0F12, 0x0010},
  {0x0F12, 0x0327},
  {0x0F12, 0x0336},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x002A, 0x1AF8},
  {0x0F12, 0x5A3C},   
  {0x002A, 0x1896},
  {0x0F12, 0x0002},   
  {0x0F12, 0x0000},   
  {0x0F12, 0x0003},
  {0x002A, 0x189E},
  {0x0F12, 0x0FB0},
  {0x002A, 0x18AC},
  {0x0F12, 0x0060},
  {0x0F12, 0x0060},
  {0x0F12, 0x05C0},
  {0x0F12, 0x05C0},
  {0x002A, 0x1AEA},
  {0x0F12, 0x8080},
  {0x0F12, 0x0080},
  {0x002A, 0x1AE0},
  {0x0F12, 0x0000},
  {0x002A, 0x1A72},
  {0x0F12, 0x0000},
  {0x002A, 0x18A2},
  {0x0F12, 0x0004},
  {0x002A, 0x1A6A},
  {0x0F12, 0x009A},
  {0x002A, 0x385E},
  {0x0F12, 0x024C},
  {0x002A, 0x0EE6},
  {0x0F12, 0x0000},
  {0x002A, 0x1B2A},
  {0x0F12, 0x0300},
  {0x0F12, 0x00D6},
  {0x0F12, 0x008D},
  {0x0F12, 0x00CF},
  {0x0F12, 0x0084},
  


  {0x0028, 0x7000},
  {0x002A, 0x3AF8},
  {0x0F12, 0xB570}, 
  {0x0F12, 0x4B39}, 
  {0x0F12, 0x4939}, 
  {0x0F12, 0x483A}, 
  {0x0F12, 0x2200}, 
  {0x0F12, 0xC008}, 
  {0x0F12, 0x6001}, 
  {0x0F12, 0x4939}, 
  {0x0F12, 0x4839}, 
  {0x0F12, 0x2401}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFBEC}, 
  {0x0F12, 0x4938}, 
  {0x0F12, 0x4839}, 
  {0x0F12, 0x2502}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFBE6}, 
  {0x0F12, 0x4837}, 
  {0x0F12, 0x0261}, 
  {0x0F12, 0x8001}, 
  {0x0F12, 0x2100}, 
  {0x0F12, 0x8041}, 
  {0x0F12, 0x4936}, 
  {0x0F12, 0x4836}, 
  {0x0F12, 0x6041}, 
  {0x0F12, 0x4936}, 
  {0x0F12, 0x4837}, 
  {0x0F12, 0x2403}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFBD8}, 
  {0x0F12, 0x4832}, 
  {0x0F12, 0x4935}, 
  {0x0F12, 0x30C0}, 
  {0x0F12, 0x63C1}, 
  {0x0F12, 0x4930}, 
  {0x0F12, 0x4834}, 
  {0x0F12, 0x3980}, 
  {0x0F12, 0x6408}, 
  {0x0F12, 0x4833}, 
  {0x0F12, 0x4934}, 
  {0x0F12, 0x6388}, 
  {0x0F12, 0x4934}, 
  {0x0F12, 0x4834}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0x2504}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFBC7}, 
  {0x0F12, 0x4933}, 
  {0x0F12, 0x4833}, 
  {0x0F12, 0x2405}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF881}, 
  {0x0F12, 0x491F}, 
  {0x0F12, 0x4830}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0x2506}, 
  {0x0F12, 0x39B6}, 
  {0x0F12, 0x1D80}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF879}, 
  {0x0F12, 0x482D}, 
  {0x0F12, 0x492D}, 
  {0x0F12, 0x2407}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0x300C}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF872}, 
  {0x0F12, 0x4829}, 
  {0x0F12, 0x492B}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0x2508}, 
  {0x0F12, 0x3010}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF86B}, 
  {0x0F12, 0x4929}, 
  {0x0F12, 0x4829}, 
  {0x0F12, 0x2409}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFBA5}, 
  {0x0F12, 0x4928}, 
  {0x0F12, 0x4828}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0x250A}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB9F}, 
  {0x0F12, 0x4927}, 
  {0x0F12, 0x4827}, 
  {0x0F12, 0x240B}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB99}, 
  {0x0F12, 0x4926}, 
  {0x0F12, 0x4826}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0x250C}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB93}, 
  {0x0F12, 0x4925}, 
  {0x0F12, 0x4825}, 
  {0x0F12, 0x240D}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB8D}, 
  {0x0F12, 0x4924}, 
  {0x0F12, 0x4824}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB88}, 
  {0x0F12, 0xBC70}, 
  {0x0F12, 0xBC08}, 
  {0x0F12, 0x4718}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x017B}, 
  {0x0F12, 0x4EC2}, 
  {0x0F12, 0x037F}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x1F90}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x3C81}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0xE38B}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x3CB9}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0xC3B1}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4780}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x3D17}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x3D53}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0xB49D}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x3DFF}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x3DB3}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0xFFFF}, 
  {0x0F12, 0x00FF}, 
  {0x0F12, 0x17E0}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x3F7B}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x053D}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0A89}, 
  {0x0F12, 0x6CD2}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0A9A}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x02D2}, 
  {0x0F12, 0x3FC9}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x9E65}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x403D}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x7C49}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x40B1}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x7C63}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x40CD}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x8F01}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x416F}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x7F3F}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x41FD}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x98C5}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0xB570}, 
  {0x0F12, 0x000C}, 
  {0x0F12, 0x0015}, 
  {0x0F12, 0x0029}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB42}, 
  {0x0F12, 0x49F8}, 
  {0x0F12, 0x00A8}, 
  {0x0F12, 0x500C}, 
  {0x0F12, 0xBC70}, 
  {0x0F12, 0xBC08}, 
  {0x0F12, 0x4718}, 
  {0x0F12, 0x6808}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x6849}, 
  {0x0F12, 0x0409}, 
  {0x0F12, 0x0C09}, 
  {0x0F12, 0x4AF3}, 
  {0x0F12, 0x8992}, 
  {0x0F12, 0x2A00}, 
  {0x0F12, 0xD00D}, 
  {0x0F12, 0x2300}, 
  {0x0F12, 0x1A89}, 
  {0x0F12, 0xD400}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0419}, 
  {0x0F12, 0x0C09}, 
  {0x0F12, 0x23FF}, 
  {0x0F12, 0x33C1}, 
  {0x0F12, 0x1810}, 
  {0x0F12, 0x4298}, 
  {0x0F12, 0xD800}, 
  {0x0F12, 0x0003}, 
  {0x0F12, 0x0418}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x4AEB}, 
  {0x0F12, 0x8150}, 
  {0x0F12, 0x8191}, 
  {0x0F12, 0x4770}, 
  {0x0F12, 0xB5F3}, 
  {0x0F12, 0x0004}, 
  {0x0F12, 0xB081}, 
  {0x0F12, 0x9802}, 
  {0x0F12, 0x6800}, 
  {0x0F12, 0x0600}, 
  {0x0F12, 0x0E00}, 
  {0x0F12, 0x2201}, 
  {0x0F12, 0x0015}, 
  {0x0F12, 0x0021}, 
  {0x0F12, 0x3910}, 
  {0x0F12, 0x408A}, 
  {0x0F12, 0x40A5}, 
  {0x0F12, 0x4FE4}, 
  {0x0F12, 0x0016}, 
  {0x0F12, 0x2C10}, 
  {0x0F12, 0xDA03}, 
  {0x0F12, 0x8839}, 
  {0x0F12, 0x43A9}, 
  {0x0F12, 0x8039}, 
  {0x0F12, 0xE002}, 
  {0x0F12, 0x8879}, 
  {0x0F12, 0x43B1}, 
  {0x0F12, 0x8079}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB0E}, 
  {0x0F12, 0x2C10}, 
  {0x0F12, 0xDA03}, 
  {0x0F12, 0x8839}, 
  {0x0F12, 0x4329}, 
  {0x0F12, 0x8039}, 
  {0x0F12, 0xE002}, 
  {0x0F12, 0x8879}, 
  {0x0F12, 0x4331}, 
  {0x0F12, 0x8079}, 
  {0x0F12, 0x49DA}, 
  {0x0F12, 0x8809}, 
  {0x0F12, 0x2900}, 
  {0x0F12, 0xD102}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB07}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x9902}, 
  {0x0F12, 0x6008}, 
  {0x0F12, 0xBCFE}, 
  {0x0F12, 0xBC08}, 
  {0x0F12, 0x4718}, 
  {0x0F12, 0xB538}, 
  {0x0F12, 0x9C04}, 
  {0x0F12, 0x0015}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0x9400}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFB02}, 
  {0x0F12, 0x4AD1}, 
  {0x0F12, 0x8811}, 
  {0x0F12, 0x2900}, 
  {0x0F12, 0xD00F}, 
  {0x0F12, 0x8820}, 
  {0x0F12, 0x4281}, 
  {0x0F12, 0xD20C}, 
  {0x0F12, 0x8861}, 
  {0x0F12, 0x8853}, 
  {0x0F12, 0x4299}, 
  {0x0F12, 0xD200}, 
  {0x0F12, 0x1E40}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x8020}, 
  {0x0F12, 0x8851}, 
  {0x0F12, 0x8061}, 
  {0x0F12, 0x4368}, 
  {0x0F12, 0x1840}, 
  {0x0F12, 0x6060}, 
  {0x0F12, 0xBC38}, 
  {0x0F12, 0xBC08}, 
  {0x0F12, 0x4718}, 
  {0x0F12, 0xB5F8}, 
  {0x0F12, 0x0004}, 
  {0x0F12, 0x6808}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x2201}, 
  {0x0F12, 0x0015}, 
  {0x0F12, 0x0021}, 
  {0x0F12, 0x3910}, 
  {0x0F12, 0x408A}, 
  {0x0F12, 0x40A5}, 
  {0x0F12, 0x4FBE}, 
  {0x0F12, 0x0016}, 
  {0x0F12, 0x2C10}, 
  {0x0F12, 0xDA03}, 
  {0x0F12, 0x8839}, 
  {0x0F12, 0x43A9}, 
  {0x0F12, 0x8039}, 
  {0x0F12, 0xE002}, 
  {0x0F12, 0x8879}, 
  {0x0F12, 0x43B1}, 
  {0x0F12, 0x8079}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFADB}, 
  {0x0F12, 0x2C10}, 
  {0x0F12, 0xDA03}, 
  {0x0F12, 0x8838}, 
  {0x0F12, 0x4328}, 
  {0x0F12, 0x8038}, 
  {0x0F12, 0xE002}, 
  {0x0F12, 0x8878}, 
  {0x0F12, 0x4330}, 
  {0x0F12, 0x8078}, 
  {0x0F12, 0x48B6}, 
  {0x0F12, 0x8800}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0xD507}, 
  {0x0F12, 0x4BB5}, 
  {0x0F12, 0x7819}, 
  {0x0F12, 0x4AB5}, 
  {0x0F12, 0x7810}, 
  {0x0F12, 0x7018}, 
  {0x0F12, 0x7011}, 
  {0x0F12, 0x49B4}, 
  {0x0F12, 0x8188}, 
  {0x0F12, 0xBCF8}, 
  {0x0F12, 0xBC08}, 
  {0x0F12, 0x4718}, 
  {0x0F12, 0xB538}, 
  {0x0F12, 0x48B2}, 
  {0x0F12, 0x4669}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFAC6}, 
  {0x0F12, 0x48B1}, 
  {0x0F12, 0x49B0}, 
  {0x0F12, 0x69C2}, 
  {0x0F12, 0x2400}, 
  {0x0F12, 0x31A8}, 
  {0x0F12, 0x2A00}, 
  {0x0F12, 0xD008}, 
  {0x0F12, 0x61C4}, 
  {0x0F12, 0x684A}, 
  {0x0F12, 0x6242}, 
  {0x0F12, 0x6282}, 
  {0x0F12, 0x466B}, 
  {0x0F12, 0x881A}, 
  {0x0F12, 0x6302}, 
  {0x0F12, 0x885A}, 
  {0x0F12, 0x6342}, 
  {0x0F12, 0x6A02}, 
  {0x0F12, 0x2A00}, 
  {0x0F12, 0xD00A}, 
  {0x0F12, 0x6204}, 
  {0x0F12, 0x6849}, 
  {0x0F12, 0x6281}, 
  {0x0F12, 0x466B}, 
  {0x0F12, 0x8819}, 
  {0x0F12, 0x6301}, 
  {0x0F12, 0x8859}, 
  {0x0F12, 0x6341}, 
  {0x0F12, 0x49A5}, 
  {0x0F12, 0x88C9}, 
  {0x0F12, 0x63C1}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFAAE}, 
  {0x0F12, 0xE7A6}, 
  {0x0F12, 0xB5F0}, 
  {0x0F12, 0xB08B}, 
  {0x0F12, 0x20FF}, 
  {0x0F12, 0x1C40}, 
  {0x0F12, 0x49A1}, 
  {0x0F12, 0x89CC}, 
  {0x0F12, 0x4E9E}, 
  {0x0F12, 0x6AB1}, 
  {0x0F12, 0x4284}, 
  {0x0F12, 0xD101}, 
  {0x0F12, 0x489F}, 
  {0x0F12, 0x6081}, 
  {0x0F12, 0x6A70}, 
  {0x0F12, 0x0200}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFAA5}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x4A96}, 
  {0x0F12, 0x8A11}, 
  {0x0F12, 0x9109}, 
  {0x0F12, 0x2101}, 
  {0x0F12, 0x0349}, 
  {0x0F12, 0x4288}, 
  {0x0F12, 0xD200}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x4A92}, 
  {0x0F12, 0x8211}, 
  {0x0F12, 0x4D97}, 
  {0x0F12, 0x8829}, 
  {0x0F12, 0x9108}, 
  {0x0F12, 0x4A8B}, 
  {0x0F12, 0x2303}, 
  {0x0F12, 0x3222}, 
  {0x0F12, 0x1F91}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA96}, 
  {0x0F12, 0x8028}, 
  {0x0F12, 0x488E}, 
  {0x0F12, 0x4987}, 
  {0x0F12, 0x6BC2}, 
  {0x0F12, 0x6AC0}, 
  {0x0F12, 0x4282}, 
  {0x0F12, 0xD201}, 
  {0x0F12, 0x8CC8}, 
  {0x0F12, 0x8028}, 
  {0x0F12, 0x88E8}, 
  {0x0F12, 0x9007}, 
  {0x0F12, 0x2240}, 
  {0x0F12, 0x4310}, 
  {0x0F12, 0x80E8}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x0041}, 
  {0x0F12, 0x194B}, 
  {0x0F12, 0x001E}, 
  {0x0F12, 0x3680}, 
  {0x0F12, 0x8BB2}, 
  {0x0F12, 0xAF04}, 
  {0x0F12, 0x527A}, 
  {0x0F12, 0x4A7D}, 
  {0x0F12, 0x188A}, 
  {0x0F12, 0x8897}, 
  {0x0F12, 0x83B7}, 
  {0x0F12, 0x33A0}, 
  {0x0F12, 0x891F}, 
  {0x0F12, 0xAE01}, 
  {0x0F12, 0x5277}, 
  {0x0F12, 0x8A11}, 
  {0x0F12, 0x8119}, 
  {0x0F12, 0x1C40}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x2806}, 
  {0x0F12, 0xD3E9}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA77}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA7D}, 
  {0x0F12, 0x4F79}, 
  {0x0F12, 0x37A8}, 
  {0x0F12, 0x2800}, 
  {0x0F12, 0xD10A}, 
  {0x0F12, 0x1FE0}, 
  {0x0F12, 0x38FD}, 
  {0x0F12, 0xD001}, 
  {0x0F12, 0x1CC0}, 
  {0x0F12, 0xD105}, 
  {0x0F12, 0x4874}, 
  {0x0F12, 0x8829}, 
  {0x0F12, 0x3818}, 
  {0x0F12, 0x6840}, 
  {0x0F12, 0x4348}, 
  {0x0F12, 0x6078}, 
  {0x0F12, 0x4972}, 
  {0x0F12, 0x6878}, 
  {0x0F12, 0x6B89}, 
  {0x0F12, 0x4288}, 
  {0x0F12, 0xD300}, 
  {0x0F12, 0x0008}, 
  {0x0F12, 0x6078}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x0041}, 
  {0x0F12, 0xAA04}, 
  {0x0F12, 0x5A53}, 
  {0x0F12, 0x194A}, 
  {0x0F12, 0x269C}, 
  {0x0F12, 0x52B3}, 
  {0x0F12, 0xAB01}, 
  {0x0F12, 0x5A59}, 
  {0x0F12, 0x32A0}, 
  {0x0F12, 0x8111}, 
  {0x0F12, 0x1C40}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x2806}, 
  {0x0F12, 0xD3F0}, 
  {0x0F12, 0x4965}, 
  {0x0F12, 0x9809}, 
  {0x0F12, 0x8208}, 
  {0x0F12, 0x9808}, 
  {0x0F12, 0x8028}, 
  {0x0F12, 0x9807}, 
  {0x0F12, 0x80E8}, 
  {0x0F12, 0x1FE0}, 
  {0x0F12, 0x38FD}, 
  {0x0F12, 0xD13B}, 
  {0x0F12, 0x4D64}, 
  {0x0F12, 0x89E8}, 
  {0x0F12, 0x1FC1}, 
  {0x0F12, 0x39FF}, 
  {0x0F12, 0xD136}, 
  {0x0F12, 0x4C5F}, 
  {0x0F12, 0x8AE0}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA4C}, 
  {0x0F12, 0x0006}, 
  {0x0F12, 0x8B20}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA50}, 
  {0x0F12, 0x9000}, 
  {0x0F12, 0x6AA1}, 
  {0x0F12, 0x6878}, 
  {0x0F12, 0x1809}, 
  {0x0F12, 0x0200}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA23}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x0022}, 
  {0x0F12, 0x3246}, 
  {0x0F12, 0x0011}, 
  {0x0F12, 0x310A}, 
  {0x0F12, 0x2305}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA20}, 
  {0x0F12, 0x66E8}, 
  {0x0F12, 0x6B23}, 
  {0x0F12, 0x0002}, 
  {0x0F12, 0x0031}, 
  {0x0F12, 0x0018}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA41}, 
  {0x0F12, 0x466B}, 
  {0x0F12, 0x8518}, 
  {0x0F12, 0x6EEA}, 
  {0x0F12, 0x6B60}, 
  {0x0F12, 0x9900}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA3A}, 
  {0x0F12, 0x466B}, 
  {0x0F12, 0x8558}, 
  {0x0F12, 0x0029}, 
  {0x0F12, 0x980A}, 
  {0x0F12, 0x3170}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA3B}, 
  {0x0F12, 0x0028}, 
  {0x0F12, 0x3060}, 
  {0x0F12, 0x8A02}, 
  {0x0F12, 0x4946}, 
  {0x0F12, 0x3128}, 
  {0x0F12, 0x808A}, 
  {0x0F12, 0x8A42}, 
  {0x0F12, 0x80CA}, 
  {0x0F12, 0x8A80}, 
  {0x0F12, 0x8108}, 
  {0x0F12, 0xB00B}, 
  {0x0F12, 0xBCF0}, 
  {0x0F12, 0xBC08}, 
  {0x0F12, 0x4718}, 
  {0x0F12, 0xB570}, 
  {0x0F12, 0x2400}, 
  {0x0F12, 0x4D46}, 
  {0x0F12, 0x4846}, 
  {0x0F12, 0x8881}, 
  {0x0F12, 0x4846}, 
  {0x0F12, 0x8041}, 
  {0x0F12, 0x2101}, 
  {0x0F12, 0x8001}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA2A}, 
  {0x0F12, 0x4842}, 
  {0x0F12, 0x3820}, 
  {0x0F12, 0x8BC0}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA2D}, 
  {0x0F12, 0x4B42}, 
  {0x0F12, 0x220D}, 
  {0x0F12, 0x0712}, 
  {0x0F12, 0x18A8}, 
  {0x0F12, 0x8806}, 
  {0x0F12, 0x00E1}, 
  {0x0F12, 0x18C9}, 
  {0x0F12, 0x81CE}, 
  {0x0F12, 0x8846}, 
  {0x0F12, 0x818E}, 
  {0x0F12, 0x8886}, 
  {0x0F12, 0x824E}, 
  {0x0F12, 0x88C0}, 
  {0x0F12, 0x8208}, 
  {0x0F12, 0x3508}, 
  {0x0F12, 0x042D}, 
  {0x0F12, 0x0C2D}, 
  {0x0F12, 0x1C64}, 
  {0x0F12, 0x0424}, 
  {0x0F12, 0x0C24}, 
  {0x0F12, 0x2C07}, 
  {0x0F12, 0xD3EC}, 
  {0x0F12, 0xE658}, 
  {0x0F12, 0xB510}, 
  {0x0F12, 0x4834}, 
  {0x0F12, 0x4C34}, 
  {0x0F12, 0x88C0}, 
  {0x0F12, 0x8060}, 
  {0x0F12, 0x2001}, 
  {0x0F12, 0x8020}, 
  {0x0F12, 0x4831}, 
  {0x0F12, 0x3820}, 
  {0x0F12, 0x8BC0}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xFA0A}, 
  {0x0F12, 0x88E0}, 
  {0x0F12, 0x4A31}, 
  {0x0F12, 0x2800}, 
  {0x0F12, 0xD003}, 
  {0x0F12, 0x4930}, 
  {0x0F12, 0x8849}, 
  {0x0F12, 0x2900}, 
  {0x0F12, 0xD009}, 
  {0x0F12, 0x2001}, 
  {0x0F12, 0x03C0}, 
  {0x0F12, 0x8050}, 
  {0x0F12, 0x80D0}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x8090}, 
  {0x0F12, 0x8110}, 
  {0x0F12, 0xBC10}, 
  {0x0F12, 0xBC08}, 
  {0x0F12, 0x4718}, 
  {0x0F12, 0x8050}, 
  {0x0F12, 0x8920}, 
  {0x0F12, 0x80D0}, 
  {0x0F12, 0x8960}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x1400}, 
  {0x0F12, 0x8090}, 
  {0x0F12, 0x89A1}, 
  {0x0F12, 0x0409}, 
  {0x0F12, 0x1409}, 
  {0x0F12, 0x8111}, 
  {0x0F12, 0x89E3}, 
  {0x0F12, 0x8A24}, 
  {0x0F12, 0x2B00}, 
  {0x0F12, 0xD104}, 
  {0x0F12, 0x17C3}, 
  {0x0F12, 0x0F5B}, 
  {0x0F12, 0x1818}, 
  {0x0F12, 0x10C0}, 
  {0x0F12, 0x8090}, 
  {0x0F12, 0x2C00}, 
  {0x0F12, 0xD1E6}, 
  {0x0F12, 0x17C8}, 
  {0x0F12, 0x0F40}, 
  {0x0F12, 0x1840}, 
  {0x0F12, 0x10C0}, 
  {0x0F12, 0x8110}, 
  {0x0F12, 0xE7E0}, 
  {0x0F12, 0xB510}, 
  {0x0F12, 0x000C}, 
  {0x0F12, 0x4919}, 
  {0x0F12, 0x2204}, 
  {0x0F12, 0x6820}, 
  {0x0F12, 0x5E8A}, 
  {0x0F12, 0x0140}, 
  {0x0F12, 0x1A80}, 
  {0x0F12, 0x0280}, 
  {0x0F12, 0x8849}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF9D8}, 
  {0x0F12, 0x6020}, 
  {0x0F12, 0xE7D2}, 
  {0x0F12, 0x38D4}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x17D0}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x5000}, 
  {0x0F12, 0xD000}, 
  {0x0F12, 0x1100}, 
  {0x0F12, 0xD000}, 
  {0x0F12, 0x171A}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x4780}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2FCA}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2FC5}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2FC6}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2ED8}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2BD0}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x17E0}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2DE8}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x37E0}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x210C}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x1484}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0xA006}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0724}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0xA000}, 
  {0x0F12, 0xD000}, 
  {0x0F12, 0x2270}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2558}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x146C}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0xB510}, 
  {0x0F12, 0x000C}, 
  {0x0F12, 0x4983}, 
  {0x0F12, 0x2208}, 
  {0x0F12, 0x6820}, 
  {0x0F12, 0x5E8A}, 
  {0x0F12, 0x0140}, 
  {0x0F12, 0x1A80}, 
  {0x0F12, 0x0280}, 
  {0x0F12, 0x88C9}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF99E}, 
  {0x0F12, 0x6020}, 
  {0x0F12, 0xE798}, 
  {0x0F12, 0xB5FE}, 
  {0x0F12, 0x000C}, 
  {0x0F12, 0x6825}, 
  {0x0F12, 0x6866}, 
  {0x0F12, 0x68A0}, 
  {0x0F12, 0x9001}, 
  {0x0F12, 0x68E7}, 
  {0x0F12, 0x1BA8}, 
  {0x0F12, 0x42B5}, 
  {0x0F12, 0xDA00}, 
  {0x0F12, 0x1B70}, 
  {0x0F12, 0x9000}, 
  {0x0F12, 0x4977}, 
  {0x0F12, 0x4878}, 
  {0x0F12, 0x884A}, 
  {0x0F12, 0x8843}, 
  {0x0F12, 0x435A}, 
  {0x0F12, 0x2304}, 
  {0x0F12, 0x5ECB}, 
  {0x0F12, 0x0A92}, 
  {0x0F12, 0x18D2}, 
  {0x0F12, 0x02D2}, 
  {0x0F12, 0x0C12}, 
  {0x0F12, 0x88CB}, 
  {0x0F12, 0x8880}, 
  {0x0F12, 0x4343}, 
  {0x0F12, 0x0A98}, 
  {0x0F12, 0x2308}, 
  {0x0F12, 0x5ECB}, 
  {0x0F12, 0x18C0}, 
  {0x0F12, 0x02C0}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x0411}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x1409}, 
  {0x0F12, 0x1400}, 
  {0x0F12, 0x1A08}, 
  {0x0F12, 0x496C}, 
  {0x0F12, 0x39E0}, 
  {0x0F12, 0x6148}, 
  {0x0F12, 0x9801}, 
  {0x0F12, 0x3040}, 
  {0x0F12, 0x7880}, 
  {0x0F12, 0x2800}, 
  {0x0F12, 0xD103}, 
  {0x0F12, 0x9801}, 
  {0x0F12, 0x0029}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF971}, 
  {0x0F12, 0x8839}, 
  {0x0F12, 0x9800}, 
  {0x0F12, 0x4281}, 
  {0x0F12, 0xD814}, 
  {0x0F12, 0x8879}, 
  {0x0F12, 0x9800}, 
  {0x0F12, 0x4281}, 
  {0x0F12, 0xD20C}, 
  {0x0F12, 0x9801}, 
  {0x0F12, 0x0029}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF96D}, 
  {0x0F12, 0x9801}, 
  {0x0F12, 0x0029}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF969}, 
  {0x0F12, 0x9801}, 
  {0x0F12, 0x0029}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF965}, 
  {0x0F12, 0xE003}, 
  {0x0F12, 0x9801}, 
  {0x0F12, 0x0029}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF960}, 
  {0x0F12, 0x9801}, 
  {0x0F12, 0x0032}, 
  {0x0F12, 0x0039}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF963}, 
  {0x0F12, 0x6020}, 
  {0x0F12, 0xE5D0}, 
  {0x0F12, 0xB57C}, 
  {0x0F12, 0x4856}, 
  {0x0F12, 0xA901}, 
  {0x0F12, 0x0004}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF8E7}, 
  {0x0F12, 0x466B}, 
  {0x0F12, 0x88D9}, 
  {0x0F12, 0x8898}, 
  {0x0F12, 0x4B51}, 
  {0x0F12, 0x3346}, 
  {0x0F12, 0x1E9A}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF95B}, 
  {0x0F12, 0x4850}, 
  {0x0F12, 0x494E}, 
  {0x0F12, 0x3812}, 
  {0x0F12, 0x3140}, 
  {0x0F12, 0x8A42}, 
  {0x0F12, 0x888B}, 
  {0x0F12, 0x18D2}, 
  {0x0F12, 0x8242}, 
  {0x0F12, 0x8AC2}, 
  {0x0F12, 0x88C9}, 
  {0x0F12, 0x1851}, 
  {0x0F12, 0x82C1}, 
  {0x0F12, 0x0020}, 
  {0x0F12, 0x4669}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF8CF}, 
  {0x0F12, 0x4849}, 
  {0x0F12, 0x214D}, 
  {0x0F12, 0x8301}, 
  {0x0F12, 0x2196}, 
  {0x0F12, 0x8381}, 
  {0x0F12, 0x211D}, 
  {0x0F12, 0x3020}, 
  {0x0F12, 0x8001}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF949}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF94F}, 
  {0x0F12, 0x4844}, 
  {0x0F12, 0x4C44}, 
  {0x0F12, 0x6E00}, 
  {0x0F12, 0x60E0}, 
  {0x0F12, 0x466B}, 
  {0x0F12, 0x8818}, 
  {0x0F12, 0x8859}, 
  {0x0F12, 0x0025}, 
  {0x0F12, 0x1A40}, 
  {0x0F12, 0x3540}, 
  {0x0F12, 0x61A8}, 
  {0x0F12, 0x483B}, 
  {0x0F12, 0x9900}, 
  {0x0F12, 0x3060}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF947}, 
  {0x0F12, 0x466B}, 
  {0x0F12, 0x8819}, 
  {0x0F12, 0x1DE0}, 
  {0x0F12, 0x30F9}, 
  {0x0F12, 0x8741}, 
  {0x0F12, 0x8859}, 
  {0x0F12, 0x8781}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x71A0}, 
  {0x0F12, 0x74A8}, 
  {0x0F12, 0xBC7C}, 
  {0x0F12, 0xBC08}, 
  {0x0F12, 0x4718}, 
  {0x0F12, 0xB5F8}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x6808}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x684A}, 
  {0x0F12, 0x0412}, 
  {0x0F12, 0x0C12}, 
  {0x0F12, 0x688E}, 
  {0x0F12, 0x68CC}, 
  {0x0F12, 0x492C}, 
  {0x0F12, 0x884B}, 
  {0x0F12, 0x4343}, 
  {0x0F12, 0x0A98}, 
  {0x0F12, 0x2304}, 
  {0x0F12, 0x5ECB}, 
  {0x0F12, 0x18C0}, 
  {0x0F12, 0x02C0}, 
  {0x0F12, 0x0C00}, 
  {0x0F12, 0x88CB}, 
  {0x0F12, 0x4353}, 
  {0x0F12, 0x0A9A}, 
  {0x0F12, 0x2308}, 
  {0x0F12, 0x5ECB}, 
  {0x0F12, 0x18D1}, 
  {0x0F12, 0x02C9}, 
  {0x0F12, 0x0C09}, 
  {0x0F12, 0x2701}, 
  {0x0F12, 0x003A}, 
  {0x0F12, 0x40AA}, 
  {0x0F12, 0x9200}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0x3A10}, 
  {0x0F12, 0x4097}, 
  {0x0F12, 0x2D10}, 
  {0x0F12, 0xDA06}, 
  {0x0F12, 0x4A25}, 
  {0x0F12, 0x9B00}, 
  {0x0F12, 0x8812}, 
  {0x0F12, 0x439A}, 
  {0x0F12, 0x4B23}, 
  {0x0F12, 0x801A}, 
  {0x0F12, 0xE003}, 
  {0x0F12, 0x4B22}, 
  {0x0F12, 0x885A}, 
  {0x0F12, 0x43BA}, 
  {0x0F12, 0x805A}, 
  {0x0F12, 0x0023}, 
  {0x0F12, 0x0032}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF8EF}, 
  {0x0F12, 0x2D10}, 
  {0x0F12, 0xDA05}, 
  {0x0F12, 0x491D}, 
  {0x0F12, 0x9A00}, 
  {0x0F12, 0x8808}, 
  {0x0F12, 0x4310}, 
  {0x0F12, 0x8008}, 
  {0x0F12, 0xE003}, 
  {0x0F12, 0x481A}, 
  {0x0F12, 0x8841}, 
  {0x0F12, 0x4339}, 
  {0x0F12, 0x8041}, 
  {0x0F12, 0x4D17}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x3580}, 
  {0x0F12, 0x88AA}, 
  {0x0F12, 0x5E30}, 
  {0x0F12, 0x2100}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF8FB}, 
  {0x0F12, 0x8030}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x88AA}, 
  {0x0F12, 0x5E20}, 
  {0x0F12, 0x2100}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF8F4}, 
  {0x0F12, 0x8020}, 
  {0x0F12, 0xE587}, 
  {0x0F12, 0xB510}, 
  {0x0F12, 0xF000}, 
  {0x0F12, 0xF8F7}, 
  {0x0F12, 0x4A0F}, 
  {0x0F12, 0x8D50}, 
  {0x0F12, 0x2800}, 
  {0x0F12, 0xD007}, 
  {0x0F12, 0x490A}, 
  {0x0F12, 0x31C0}, 
  {0x0F12, 0x684B}, 
  {0x0F12, 0x490C}, 
  {0x0F12, 0x4283}, 
  {0x0F12, 0xD202}, 
  {0x0F12, 0x8D90}, 
  {0x0F12, 0x81C8}, 
  {0x0F12, 0xE6A0}, 
  {0x0F12, 0x8DD0}, 
  {0x0F12, 0x81C8}, 
  {0x0F12, 0xE69D}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2558}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2AB8}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x145E}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2698}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2BB8}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x2998}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0x1100}, 
  {0x0F12, 0xD000}, 
  {0x0F12, 0x4780}, 
  {0x0F12, 0x7000}, 
  {0x0F12, 0xE200}, 
  {0x0F12, 0xD000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x1789}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x16F1}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xC3B1}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xC36D}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xF6D7}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xB49D}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x7EDF}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x448D}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xF004}, 
  {0x0F12, 0xE51F}, 
  {0x0F12, 0x29EC}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x2EF1}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xEE03}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xA58B}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x7C49}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x7C63}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x2DB7}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xEB3D}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xF061}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xF0EF}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xF004}, 
  {0x0F12, 0xE51F}, 
  {0x0F12, 0x2824}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x8EDD}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x8DCB}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x8E17}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x98C5}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x7C7D}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x7E31}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x7EAB}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0x7501}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x4778}, 
  {0x0F12, 0x46C0}, 
  {0x0F12, 0xC000}, 
  {0x0F12, 0xE59F}, 
  {0x0F12, 0xFF1C}, 
  {0x0F12, 0xE12F}, 
  {0x0F12, 0xF63F}, 
  {0x0F12, 0x0000}, 
  


  {0x0028, 0xD000},
  {0x002A, 0x1000},
  {0x0F12, 0x0001},
  



  {0x0028, 0x7000},
  {0x002A, 0x01FC},
  {0x0F12, 0x0001}, 
  {0x002A, 0x01FE},
  {0x0F12, 0x0003}, 
  {0x0F12, 0x0000}, 
  {0x002A, 0x0204},
  {0x0F12, 0x0061}, 
  {0x002A, 0x020C},
  {0x0F12, 0x2F0C}, 
  {0x0F12, 0x0190}, 
  {0x002A, 0x0294},
  {0x0F12, 0x01C7}, 
  {0x0F12, 0x01C7}, 
  {0x0F12, 0x0072}, 
  {0x0F12, 0x0072}, 
  {0x0F12, 0x01D5}, 
  {0x0F12, 0x01D5}, 
  {0x0F12, 0x0055}, 
  {0x0F12, 0x0055}, 
  {0x0F12, 0x0001}, 
  
  {0x002A, 0x070E},
  {0x0F12, 0x00FF}, 
  {0x002A, 0x071E},
  {0x0F12, 0x0000}, 
  {0x002A, 0x163C},
  {0x0F12, 0x0000}, 
  {0x002A, 0x1648},
  {0x0F12, 0x9000}, 
  {0x002A, 0x1652},
  {0x0F12, 0x0002}, 
  {0x0F12, 0x0000}, 
  {0x002A, 0x15E0},
  {0x0F12, 0x0902}, 
  
  {0x002A, 0x164C},
  {0x0F12, 0x0003}, 
  {0x002A, 0x163E},
  {0x0F12, 0x00E5}, 
  {0x0F12, 0x0098}, 
  {0x002A, 0x15D4},
  {0x0F12, 0x0020}, 
  {0x0F12, 0xD020}, 
  {0x002A, 0x169A},
  {0x0F12, 0xFF95}, 
  {0x002A, 0x166A},
  {0x0F12, 0x0280}, 
  {0x002A, 0x1676},
  {0x0F12, 0x03FF}, 
  {0x0F12, 0x0320}, 
  {0x002A, 0x16BC},
  {0x0F12, 0x0030}, 
  {0x002A, 0x16E0},
  {0x0F12, 0x0060}, 
  {0x002A, 0x16D4},
  {0x0F12, 0x0010}, 
  {0x002A, 0x1656},
  {0x0F12, 0x0000}, 
  {0x002A, 0x15E6},
  {0x0F12, 0x003C}, 
  
  {0x0F12, 0x0018}, 
  {0x0F12, 0x002A}, 
  {0x0F12, 0x0030}, 
  {0x0F12, 0x0036}, 
  {0x0F12, 0x003C}, 
  {0x0F12, 0x0042}, 
  {0x0F12, 0x0048}, 
  {0x0F12, 0x004E}, 
  {0x0F12, 0x0054}, 
  {0x0F12, 0x005A}, 
  {0x0F12, 0x0060}, 
  {0x0F12, 0x0066}, 
  {0x0F12, 0x006C}, 
  {0x0F12, 0x0072}, 
  {0x0F12, 0x0078}, 
  {0x0F12, 0x007E}, 
  {0x0F12, 0x0084}, 
  {0x0F12, 0x008A}, 
  {0x0F12, 0x0090}, 
  {0x0F12, 0x0096}, 
  {0x0F12, 0x009C}, 
  {0x0F12, 0x00A2}, 
  {0x0F12, 0x00A8}, 
  {0x0F12, 0x00AE}, 
  {0x0F12, 0x00B4}, 
  {0x0F12, 0x00BA}, 
  
  {0x002A, 0x1722},
  {0x0F12, 0x8000}, 
  {0x0F12, 0x0006}, 
  {0x0F12, 0x3FF0}, 
  {0x0F12, 0x03E8}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0020}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x00C0}, 
  {0x0F12, 0x00E0}, 
  
  {0x002A, 0x028C},
  {0x0F12, 0x0003}, 
  
  {0x002A, 0x08B4},
  {0x0F12, 0x0001}, 
  
  {0x002A, 0x08BC},
  {0x0F12, 0x00C0}, 
  {0x0F12, 0x00DF}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0125}, 
  {0x0F12, 0x015F}, 
  {0x0F12, 0x017C}, 
  {0x0F12, 0x0194}, 
  
  {0x002A, 0x08F6},
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4500}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  
  {0x0F12, 0x4800}, 
  {0x0F12, 0x4200}, 
  {0x0F12, 0x4000}, 
  {0x0F12, 0x4000}, 
  
  {0x002A, 0x08F4},
  {0x0F12, 0x0001}, 
  

  {0x002A, 0x0F30},
  {0x0F12, 0x0001},     
  
  {0x002A, 0x0F2A},
  {0x0F12, 0x0000}, 
  {0x002A, 0x04E6},
  {0x0F12, 0x077F}, 
  
  

  {0x002A, 0x1484},
  {0x0F12, 0x003C},     
  
  {0x002A, 0x148A},
  {0x0F12, 0x000F},    
  
  {0x002A, 0x0588},
  {0x0F12, 0x0000}, 
  
  {0x002A, 0x0544},
  {0x0F12, 0x0111},    
  {0x0F12, 0x00EF},    
  
  {0x002A, 0x0608},
  {0x0F12, 0x0001},   
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0800}, 
  {0x0F12, 0x0100},     
  
  {0x002A, 0x0610}, 
  {0x0F12, 0x0001},
  {0x0F12, 0x0000},
  {0x0F12, 0x0A3C},
  {0x0F12, 0x0000},
  {0x0F12, 0x0D04},
  {0x0F12, 0x0000},
  {0x0F12, 0x4008},
  {0x0F12, 0x0000},
  {0x0F12, 0x7000},
  {0x0F12, 0x0000},
  {0x0F12, 0x9C00},
  {0x0F12, 0x0000},
  {0x0F12, 0xAD00},
  {0x0F12, 0x0001},
  {0x0F12, 0xF1D4},
  {0x0F12, 0x0002},
  {0x0F12, 0xDC00},
  {0x0F12, 0x0005},
  {0x0F12, 0xDC00},
  {0x0F12, 0x0005},
  
  {0x002A, 0x0638}, 
  {0x0F12, 0x0001},
  {0x0F12, 0x0000},
  {0x0F12, 0x0A3C},
  {0x0F12, 0x0000},
  {0x0F12, 0x0D05},
  {0x0F12, 0x0000},
  {0x0F12, 0x3408},
  {0x0F12, 0x0000},
  {0x0F12, 0x3408},
  {0x0F12, 0x0000},
  {0x0F12, 0x6810},
  {0x0F12, 0x0000},
  {0x0F12, 0x8214},
  {0x0F12, 0x0000},
  {0x0F12, 0xC350},
  {0x0F12, 0x0000},
  {0x0F12, 0xC350},
  {0x0F12, 0x0000},
  {0x0F12, 0xC350},
  {0x0F12, 0x0000},
  
  {0x002A, 0x05A2},
  {0x0F12, 0x1000}, 
  
  {0x002A, 0x06B8},
  {0x0F12, 0x452C},
  {0x0F12, 0x0005},    
  

  {0x002A, 0x1492},
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0102}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0202}, 
  {0x0F12, 0x0202}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0302}, 
  {0x0F12, 0x0203}, 
  {0x0F12, 0x0102}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0302}, 
  {0x0F12, 0x0203}, 
  {0x0F12, 0x0102}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0202}, 
  {0x0F12, 0x0202}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0102}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0101}, 
  

  {0x002A, 0x145E},
  {0x0F12, 0x0580}, 
  {0x0F12, 0x0428}, 
  {0x0F12, 0x0780}, 
  
  {0x002A, 0x1464},
  {0x0F12, 0x0008}, 
  {0x0F12, 0x0190}, 
  {0x0F12, 0x00A0}, 
  {0x0F12, 0x0004}, 
  {0x0F12, 0x0002}, 
  
  {0x002A, 0x144E},
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0f12, 0x00C2}, 
  {0x0F12, 0x0002}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0074}, 
  {0x0F12, 0x0001}, 
  
  {0x002A, 0x11F0},
  {0x0F12, 0x012C}, 
  {0x0F12, 0x0121}, 
  {0x0F12, 0x02DF}, 
  {0x0F12, 0x0314}, 
  
  {0x002A, 0x120E},
  {0x0F12, 0x0000}, 
  {0x0F12, 0x05FD}, 
  {0x0F12, 0x036B}, 
  {0x0F12, 0x0020}, 
  {0x0F12, 0x001A}, 
  
  {0x002A, 0x1278},
  {0x0F12, 0xFEF7}, 
  {0x0F12, 0x0021}, 
  {0x0F12, 0x07D0}, 
  {0x0F12, 0x07D0}, 
  {0x0F12, 0x01C8}, 
  {0x0F12, 0x0096}, 
  {0x0F12, 0x0004}, 
  
  {0x002A, 0x1224},
  {0x0F12, 0x0032}, 
  {0x0F12, 0x001E}, 
  {0x0F12, 0x00E2}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0002}, 
  {0x002A, 0x2BA4},
  {0x0F12, 0x0002},         
  
  {0x002A, 0x11FC},
  {0x0F12, 0x000C}, 
  
  {0x002A, 0x1208},
  {0x0F12, 0x0020},         
  
  {0x002A, 0x101C},
  {0x0F12, 0x0360}, 
  {0x0F12, 0x036C}, 
  {0x0F12, 0x0320}, 
  {0x0F12, 0x038A}, 
  {0x0F12, 0x02E8}, 
  {0x0F12, 0x0380}, 
  {0x0F12, 0x02BE}, 
  {0x0F12, 0x035A}, 
  {0x0F12, 0x0298}, 
  {0x0F12, 0x0334}, 
  {0x0F12, 0x0272}, 
  {0x0F12, 0x030E}, 
  {0x0F12, 0x024C}, 
  {0x0F12, 0x02EA}, 
  {0x0F12, 0x0230}, 
  {0x0F12, 0x02CC}, 
  {0x0F12, 0x0214}, 
  {0x0F12, 0x02B0}, 
  {0x0F12, 0x01F8}, 
  {0x0F12, 0x0294}, 
  {0x0F12, 0x01DC}, 
  {0x0F12, 0x0278}, 
  {0x0F12, 0x01C0}, 
  {0x0F12, 0x0264}, 
  {0x0F12, 0x01AA}, 
  {0x0F12, 0x0250}, 
  {0x0F12, 0x0196}, 
  {0x0F12, 0x023C}, 
  {0x0F12, 0x0180}, 
  {0x0F12, 0x0228}, 
  {0x0F12, 0x016C}, 
  {0x0F12, 0x0214}, 
  {0x0F12, 0x0168}, 
  {0x0F12, 0x0200}, 
  {0x0F12, 0x0172}, 
  {0x0F12, 0x01EC}, 
  {0x0F12, 0x019A}, 
  {0x0F12, 0x01D8}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  
  {0x0F12, 0x0005}, 
  {0x002A, 0x1070},
  {0x0F12, 0x0013}, 
  {0x002A, 0x1074},
  {0x0F12, 0x00EC}, 
  
  {0x002A, 0x1078},
  {0x0F12, 0x0232}, 
  {0x0F12, 0x025A}, 
  {0x0F12, 0x021E}, 
  {0x0F12, 0x0274}, 
  {0x0F12, 0x020E}, 
  {0x0F12, 0x028E}, 
  {0x0F12, 0x0200}, 
  {0x0F12, 0x0290}, 
  {0x0F12, 0x01F4}, 
  {0x0F12, 0x0286}, 
  {0x0F12, 0x01E8}, 
  {0x0F12, 0x027E}, 
  {0x0F12, 0x01DE}, 
  {0x0F12, 0x0274}, 
  {0x0F12, 0x01D2}, 
  {0x0F12, 0x0268}, 
  {0x0F12, 0x01D0}, 
  {0x0F12, 0x025E}, 
  {0x0F12, 0x01D6}, 
  {0x0F12, 0x0252}, 
  {0x0F12, 0x01E2}, 
  {0x0F12, 0x0248}, 
  {0x0F12, 0x01F4}, 
  {0x0F12, 0x021A}, 
  
  {0x0F12, 0x0004}, 
  {0x002A, 0x10AC},
  {0x0F12, 0x000C}, 
  {0x002A, 0x10B0},
  {0x0F12, 0x01DA}, 
  
  {0x002A, 0x10B4},
  {0x0F12, 0x0348}, 
  {0x0F12, 0x03B6}, 
  {0x0F12, 0x02B8}, 
  {0x0F12, 0x03B6}, 
  {0x0F12, 0x0258}, 
  {0x0F12, 0x038E}, 
  {0x0F12, 0x0212}, 
  {0x0F12, 0x0348}, 
  {0x0F12, 0x01CC}, 
  {0x0F12, 0x030C}, 
  {0x0F12, 0x01A2}, 
  {0x0F12, 0x02D2}, 
  {0x0F12, 0x0170}, 
  {0x0F12, 0x02A6}, 
  {0x0F12, 0x014C}, 
  {0x0F12, 0x0280}, 
  {0x0F12, 0x0128}, 
  {0x0F12, 0x025C}, 
  {0x0F12, 0x0146}, 
  {0x0F12, 0x0236}, 
  {0x0F12, 0x0164}, 
  {0x0F12, 0x0212}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  
  {0x0F12, 0x0006}, 
  {0x002A, 0x10E8},
  {0x0F12, 0x000B}, 
  {0x002A, 0x10EC},
  {0x0F12, 0x00D2}, 
  
  {0x002A, 0x10F0},
  {0x0F12, 0x039A},
  {0x0F12, 0x0000}, 
  {0x0F12, 0x00FE},
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2284},
  {0x0F12, 0x0000},         
  
  {0x002A, 0x1434},
  {0x0F12, 0x02C1}, 
  {0x0F12, 0x033A}, 
  {0x0F12, 0x038A}, 
  {0x0F12, 0x101A}, 
  {0x0F12, 0x1075}, 
  {0x0F12, 0x113D}, 
  {0x0F12, 0x113F}, 
  {0x0F12, 0x11AF}, 
  {0x0F12, 0x11F0}, 
  {0x0F12, 0x00B2}, 
  {0x0F12, 0x00B8}, 
  {0x0F12, 0x00CA}, 
  {0x0F12, 0x009D}, 
  
  {0x002A, 0x13A4},
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFA0}, 
  {0x0F12, 0xFFEE}, 
  {0x0F12, 0x0096}, 
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFA0}, 
  {0x0F12, 0xFFEE}, 
  {0x0F12, 0x0096}, 
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFE0}, 
  {0x0F12, 0xFFA0}, 
  {0x0F12, 0xFFEE}, 
  {0x0F12, 0x0096}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFF38}, 
  {0x0F12, 0xFEF2}, 
  {0x0F12, 0xFE5C}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFF38}, 
  {0x0F12, 0xFEF2}, 
  {0x0F12, 0xFE5C}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFF38}, 
  {0x0F12, 0xFEF2}, 
  {0x0F12, 0xFE5C}, 
  
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0xFFC0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0xFFD0}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  

  {0x002A, 0x08A6},
  {0x0F12, 0x0050}, 
  {0x0F12, 0x00F0}, 
  {0x0F12, 0x0110}, 
  {0x0F12, 0x0120}, 
  {0x0F12, 0x0130}, 
  {0x0F12, 0x0162}, 
  
  {0x0F12, 0x0001}, 
  
  {0x002A, 0x0898},
  {0x0F12, 0x4800}, 
  {0x0F12, 0x7000},
  {0x002A, 0x08A0},
  {0x0F12, 0x48D8}, 
  {0x0F12, 0x7000},
  
  {0x002A, 0x4800},
  {0x0F12, 0x0119}, 
  {0x0F12, 0xFFA9}, 
  {0x0F12, 0xFF9D}, 
  {0x0F12, 0xFF30}, 
  {0x0F12, 0x0130}, 
  {0x0F12, 0xFF8E}, 
  {0x0F12, 0xFFF8}, 
  {0x0F12, 0xFFAC}, 
  {0x0F12, 0x0137}, 
  {0x0F12, 0x0087}, 
  {0x0F12, 0x00D0}, 
  {0x0F12, 0xFEE3}, 
  {0x0F12, 0x0162}, 
  {0x0F12, 0xFF77}, 
  {0x0F12, 0x00E8}, 
  {0x0F12, 0xFF40}, 
  {0x0F12, 0x0114}, 
  {0x0F12, 0x00F4}, 
  
  {0x0F12, 0x0119}, 
  {0x0F12, 0xFFA9}, 
  {0x0F12, 0xFF9D}, 
  {0x0F12, 0xFF30}, 
  {0x0F12, 0x0130}, 
  {0x0F12, 0xFF8E}, 
  {0x0F12, 0xFFF8}, 
  {0x0F12, 0xFFAC}, 
  {0x0F12, 0x0137}, 
  {0x0F12, 0x0087}, 
  {0x0F12, 0x00D0}, 
  {0x0F12, 0xFEE3}, 
  {0x0F12, 0x0162}, 
  {0x0F12, 0xFF77}, 
  {0x0F12, 0x00E8}, 
  {0x0F12, 0xFF40}, 
  {0x0F12, 0x0114}, 
  {0x0F12, 0x00F4}, 
  
  {0x0F12, 0x0204}, 
  {0x0F12, 0xFFB2}, 
  {0x0F12, 0xFFF5}, 
  {0x0F12, 0xFEE7}, 
  {0x0F12, 0x0161}, 
  {0x0F12, 0xFF10}, 
  {0x0F12, 0xFFDD}, 
  {0x0F12, 0xFFE6}, 
  {0x0F12, 0x01B2}, 
  {0x0F12, 0x00F2}, 
  {0x0F12, 0x00CA}, 
  {0x0F12, 0xFF48}, 
  {0x0F12, 0x0151}, 
  {0x0F12, 0xFF50}, 
  {0x0F12, 0x0147}, 
  {0x0F12, 0xFF75}, 
  {0x0F12, 0x01BA}, 
  {0x0F12, 0x018C}, 
  
  {0x0F12, 0x0204}, 
  {0x0F12, 0xFFB2}, 
  {0x0F12, 0xFFF5}, 
  {0x0F12, 0xFEF1}, 
  {0x0F12, 0x014E}, 
  {0x0F12, 0xFF18}, 
  {0x0F12, 0xFFE6}, 
  {0x0F12, 0xFFDD}, 
  {0x0F12, 0x01B2}, 
  {0x0F12, 0x00F2}, 
  {0x0F12, 0x00CA}, 
  {0x0F12, 0xFF48}, 
  {0x0F12, 0x0151}, 
  {0x0F12, 0xFF50}, 
  {0x0F12, 0x0147}, 
  {0x0F12, 0xFF75}, 
  {0x0F12, 0x0187}, 
  {0x0F12, 0x01BF}, 
  
  {0x0F12, 0x0204}, 
  {0x0F12, 0xFFB2}, 
  {0x0F12, 0xFFF5}, 
  {0x0F12, 0xFEF1}, 
  {0x0F12, 0x014E}, 
  {0x0F12, 0xFF18}, 
  {0x0F12, 0xFFE6}, 
  {0x0F12, 0xFFDD}, 
  {0x0F12, 0x01B2}, 
  {0x0F12, 0x00F2}, 
  {0x0F12, 0x00CA}, 
  {0x0F12, 0xFF48}, 
  {0x0F12, 0x0151}, 
  {0x0F12, 0xFF50}, 
  {0x0F12, 0x0147}, 
  {0x0F12, 0xFF75}, 
  {0x0F12, 0x0187}, 
  {0x0F12, 0x01BF}, 
  
  {0x0F12, 0x0204}, 
  {0x0F12, 0xFFB2}, 
  {0x0F12, 0xFFF5}, 
  {0x0F12, 0xFEF1}, 
  {0x0F12, 0x014E}, 
  {0x0F12, 0xFF18}, 
  {0x0F12, 0xFFE6}, 
  {0x0F12, 0xFFDD}, 
  {0x0F12, 0x01B2}, 
  {0x0F12, 0x00F2}, 
  {0x0F12, 0x00CA}, 
  {0x0F12, 0xFF48}, 
  {0x0F12, 0x0151}, 
  {0x0F12, 0xFF50}, 
  {0x0F12, 0x0147}, 
  {0x0F12, 0xFF75}, 
  {0x0F12, 0x0187}, 
  {0x0F12, 0x01BF}, 
  
  {0x0F12, 0x01E5}, 
  {0x0F12, 0xFFA4}, 
  {0x0F12, 0xFFDC}, 
  {0x0F12, 0xFE87}, 
  {0x0F12, 0x013C}, 
  {0x0F12, 0xFF2A}, 
  {0x0F12, 0xFFD2}, 
  {0x0F12, 0xFFDF}, 
  {0x0F12, 0x0236}, 
  {0x0F12, 0x00EC}, 
  {0x0F12, 0x00F8}, 
  {0x0F12, 0xFF34}, 
  {0x0F12, 0x01CE}, 
  {0x0F12, 0xFF83}, 
  {0x0F12, 0x0195}, 
  {0x0F12, 0xFEF3}, 
  {0x0F12, 0x0126}, 
  {0x0F12, 0x0162}, 
  
  

  {0x002A, 0x0734},
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0003}, 
  {0x0F12, 0x000F}, 
  {0x0F12, 0x002B}, 
  {0x0F12, 0x0069}, 
  {0x0F12, 0x00D9}, 
  {0x0F12, 0x0138}, 
  {0x0F12, 0x0163}, 
  {0x0F12, 0x0189}, 
  {0x0F12, 0x01C6}, 
  {0x0F12, 0x01F8}, 
  {0x0F12, 0x0222}, 
  {0x0F12, 0x0249}, 
  {0x0F12, 0x028D}, 
  {0x0F12, 0x02C9}, 
  {0x0F12, 0x0327}, 
  {0x0F12, 0x0371}, 
  {0x0F12, 0x03AC}, 
  {0x0F12, 0x03DD}, 
  {0x0F12, 0x03FF}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0003}, 
  {0x0F12, 0x000F}, 
  {0x0F12, 0x002B}, 
  {0x0F12, 0x0069}, 
  {0x0F12, 0x00D9}, 
  {0x0F12, 0x0138}, 
  {0x0F12, 0x0163}, 
  {0x0F12, 0x0189}, 
  {0x0F12, 0x01C6}, 
  {0x0F12, 0x01F8}, 
  {0x0F12, 0x0222}, 
  {0x0F12, 0x0249}, 
  {0x0F12, 0x028D}, 
  {0x0F12, 0x02C9}, 
  {0x0F12, 0x0327}, 
  {0x0F12, 0x0371}, 
  {0x0F12, 0x03AC}, 
  {0x0F12, 0x03DD}, 
  {0x0F12, 0x03FF}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0003}, 
  {0x0F12, 0x000F}, 
  {0x0F12, 0x002B}, 
  {0x0F12, 0x0069}, 
  {0x0F12, 0x00D9}, 
  {0x0F12, 0x0138}, 
  {0x0F12, 0x0163}, 
  {0x0F12, 0x0189}, 
  {0x0F12, 0x01C6}, 
  {0x0F12, 0x01F8}, 
  {0x0F12, 0x0222}, 
  {0x0F12, 0x0249}, 
  {0x0F12, 0x028D}, 
  {0x0F12, 0x02C9}, 
  {0x0F12, 0x0327}, 
  {0x0F12, 0x0371}, 
  {0x0F12, 0x03AC}, 
  {0x0F12, 0x03DD}, 
  {0x0F12, 0x03FF}, 
  
  {0x0F12, 0x0001}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0019}, 
  {0x0F12, 0x0036}, 
  {0x0F12, 0x006F}, 
  {0x0F12, 0x00D8}, 
  {0x0F12, 0x0135}, 
  {0x0F12, 0x015F}, 
  {0x0F12, 0x0185}, 
  {0x0F12, 0x01C1}, 
  {0x0F12, 0x01F3}, 
  {0x0F12, 0x0220}, 
  {0x0F12, 0x024A}, 
  {0x0F12, 0x0291}, 
  {0x0F12, 0x02D0}, 
  {0x0F12, 0x032A}, 
  {0x0F12, 0x036A}, 
  {0x0F12, 0x039F}, 
  {0x0F12, 0x03CC}, 
  {0x0F12, 0x03F9}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0019}, 
  {0x0F12, 0x0036}, 
  {0x0F12, 0x006F}, 
  {0x0F12, 0x00D8}, 
  {0x0F12, 0x0135}, 
  {0x0F12, 0x015F}, 
  {0x0F12, 0x0185}, 
  {0x0F12, 0x01C1}, 
  {0x0F12, 0x01F3}, 
  {0x0F12, 0x0220}, 
  {0x0F12, 0x024A}, 
  {0x0F12, 0x0291}, 
  {0x0F12, 0x02D0}, 
  {0x0F12, 0x032A}, 
  {0x0F12, 0x036A}, 
  {0x0F12, 0x039F}, 
  {0x0F12, 0x03CC}, 
  {0x0F12, 0x03F9}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0019}, 
  {0x0F12, 0x0036}, 
  {0x0F12, 0x006F}, 
  {0x0F12, 0x00D8}, 
  {0x0F12, 0x0135}, 
  {0x0F12, 0x015F}, 
  {0x0F12, 0x0185}, 
  {0x0F12, 0x01C1}, 
  {0x0F12, 0x01F3}, 
  {0x0F12, 0x0220}, 
  {0x0F12, 0x024A}, 
  {0x0F12, 0x0291}, 
  {0x0F12, 0x02D0}, 
  {0x0F12, 0x032A}, 
  {0x0F12, 0x036A}, 
  {0x0F12, 0x039F}, 
  {0x0F12, 0x03CC}, 
  {0x0F12, 0x03F9}, 
  
  {0x002A, 0x0944},
  {0x0F12, 0x0050}, 
  {0x0F12, 0x00B0}, 
  {0x0F12, 0x0196}, 
  {0x0F12, 0x0245}, 
  {0x0F12, 0x0300}, 
  
  {0x002A, 0x0938},
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0014}, 
  {0x0F12, 0x00D2}, 
  {0x0F12, 0x0384}, 
  {0x0F12, 0x07D0}, 
  {0x0F12, 0x1388}, 
  
  {0x002A, 0x0976},
  {0x0F12, 0x0070}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x01CC}, 
  {0x0F12, 0x01CC}, 
  {0x0F12, 0x01CC}, 
  {0x0F12, 0x01CC}, 
  {0x0F12, 0x01CC}, 
  {0x0F12, 0x0180}, 
  {0x0F12, 0x0196}, 
  
  {0x002A, 0x098C},
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x00C0}, 
  {0x0F12, 0x0064}, 
  {0x0F12, 0x0384}, 
  {0x0F12, 0x005F}, 
  {0x0F12, 0x01F4}, 
  {0x0F12, 0x0070}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x00A0}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x00A0}, 
  {0x0F12, 0x1430}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0204}, 
  {0x0F12, 0x3604}, 
  {0x0F12, 0x032A}, 
  {0x0F12, 0x0403}, 
  {0x0F12, 0x1B06}, 
  {0x0F12, 0x6015}, 
  {0x0F12, 0x00C0}, 
  {0x0F12, 0x6080}, 
  {0x0F12, 0x4080}, 
  {0x0F12, 0x0640}, 
  {0x0F12, 0x0306}, 
  {0x0F12, 0x2003}, 
  {0x0F12, 0xFF01}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0400}, 
  {0x0F12, 0x365A}, 
  {0x0F12, 0x102A}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0600}, 
  {0x0F12, 0x5A0F}, 
  {0x0F12, 0x0505}, 
  {0x0F12, 0x1802}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2006}, 
  {0x0F12, 0x3028}, 
  {0x0F12, 0x0418}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0800}, 
  {0x0F12, 0x1804}, 
  {0x0F12, 0x4008}, 
  {0x0F12, 0x0540}, 
  {0x0F12, 0x8006}, 
  {0x0F12, 0x0020}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x1E10}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0705}, 
  {0x0F12, 0x0206}, 
  {0x0F12, 0x0304}, 
  {0x0F12, 0x0309}, 
  {0x0F12, 0x0305}, 
  {0x0F12, 0x2006}, 
  {0x0F12, 0x1320}, 
  {0x0F12, 0x1014}, 
  {0x0F12, 0x1010}, 
  {0x0F12, 0x0C10}, 
  {0x0F12, 0x1A0C}, 
  {0x0F12, 0x4A18}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x0350}, 
  {0x0F12, 0x0180}, 
  {0x0F12, 0x0A0A}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x2A36}, 
  {0x0F12, 0x6024}, 
  {0x0F12, 0x2A36}, 
  {0x0F12, 0xFFFF}, 
  {0x0F12, 0x0808}, 
  {0x0F12, 0x0A01}, 
  {0x0F12, 0x010A}, 
  {0x0F12, 0x2701}, 
  {0x0F12, 0x241E}, 
  {0x0F12, 0x2E60}, 
  {0x0F12, 0xFF22}, 
  {0x0F12, 0x40FF}, 
  {0x0F12, 0x0009}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x00C0}, 
  {0x0F12, 0x0064}, 
  {0x0F12, 0x0384}, 
  {0x0F12, 0x0051}, 
  {0x0F12, 0x01F4}, 
  {0x0F12, 0x0070}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x00A0}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0060}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x1430}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0204}, 
  {0x0F12, 0x2404}, 
  {0x0F12, 0x031B}, 
  {0x0F12, 0x0103}, 
  {0x0F12, 0x1205}, 
  {0x0F12, 0x400D}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x1980}, 
  {0x0F12, 0x272E}, 
  {0x0F12, 0x0629}, 
  {0x0F12, 0x0306}, 
  {0x0F12, 0x2003}, 
  {0x0F12, 0xFF01}, 
  {0x0F12, 0x0404}, 
  {0x0F12, 0x0300}, 
  {0x0F12, 0x245A}, 
  {0x0F12, 0x1018}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0B00}, 
  {0x0F12, 0x5A0F}, 
  {0x0F12, 0x0505}, 
  {0x0F12, 0x1802}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2006}, 
  {0x0F12, 0x3828}, 
  {0x0F12, 0x0425}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0800}, 
  {0x0F12, 0x1004}, 
  {0x0F12, 0x4008}, 
  {0x0F12, 0x0540}, 
  {0x0F12, 0x8006}, 
  {0x0F12, 0x0020}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x1E10}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0405}, 
  {0x0F12, 0x0205}, 
  {0x0F12, 0x0304}, 
  {0x0F12, 0x0409}, 
  {0x0F12, 0x0306}, 
  {0x0F12, 0x0407}, 
  {0x0F12, 0x2204}, 
  {0x0F12, 0x021C}, 
  {0x0F12, 0x1102}, 
  {0x0F12, 0x0611}, 
  {0x0F12, 0x1A02}, 
  {0x0F12, 0x8018}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x0374}, 
  {0x0F12, 0x0180}, 
  {0x0F12, 0x0A0A}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x141D}, 
  {0x0F12, 0x6024}, 
  {0x0F12, 0x1217}, 
  {0x0F12, 0xFFFF}, 
  {0x0F12, 0x0808}, 
  {0x0F12, 0x0A01}, 
  {0x0F12, 0x010A}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x2400}, 
  {0x0F12, 0x1660}, 
  {0x0F12, 0xFF10}, 
  {0x0F12, 0x40FF}, 
  {0x0F12, 0x0009}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x00C0}, 
  {0x0F12, 0x0064}, 
  {0x0F12, 0x0384}, 
  {0x0F12, 0x0043}, 
  {0x0F12, 0x01F4}, 
  {0x0F12, 0x0070}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x00A0}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0060}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x1430}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0204}, 
  {0x0F12, 0x1B04}, 
  {0x0F12, 0x0312}, 
  {0x0F12, 0x0003}, 
  {0x0F12, 0x0C03}, 
  {0x0F12, 0x2806}, 
  {0x0F12, 0x0060}, 
  {0x0F12, 0x1580}, 
  {0x0F12, 0x2020}, 
  {0x0F12, 0x0620}, 
  {0x0F12, 0x0306}, 
  {0x0F12, 0x2003}, 
  {0x0F12, 0xFF01}, 
  {0x0F12, 0x0404}, 
  {0x0F12, 0x0300}, 
  {0x0F12, 0x145A}, 
  {0x0F12, 0x1010}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0E00}, 
  {0x0F12, 0x5A0F}, 
  {0x0F12, 0x0504}, 
  {0x0F12, 0x1802}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2006}, 
  {0x0F12, 0x3828}, 
  {0x0F12, 0x0428}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x8000}, 
  {0x0F12, 0x0A04}, 
  {0x0F12, 0x4008}, 
  {0x0F12, 0x0540}, 
  {0x0F12, 0x8006}, 
  {0x0F12, 0x0020}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x1E10}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0405}, 
  {0x0F12, 0x0207}, 
  {0x0F12, 0x0304}, 
  {0x0F12, 0x0409}, 
  {0x0F12, 0x0306}, 
  {0x0F12, 0x0407}, 
  {0x0F12, 0x2404}, 
  {0x0F12, 0x0221}, 
  {0x0F12, 0x1202}, 
  {0x0F12, 0x0613}, 
  {0x0F12, 0x1A02}, 
  {0x0F12, 0x8018}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x0180}, 
  {0x0F12, 0x0A0A}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x121B}, 
  {0x0F12, 0x6024}, 
  {0x0F12, 0x0C0C}, 
  {0x0F12, 0xFFFF}, 
  {0x0F12, 0x0808}, 
  {0x0F12, 0x0A01}, 
  {0x0F12, 0x010A}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x2400}, 
  {0x0F12, 0x0460}, 
  {0x0F12, 0xFF04}, 
  {0x0F12, 0x40FF}, 
  {0x0F12, 0x0009}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x00C0}, 
  {0x0F12, 0x0064}, 
  {0x0F12, 0x0384}, 
  {0x0F12, 0x0032}, 
  {0x0F12, 0x01F4}, 
  {0x0F12, 0x0070}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x00A0}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0060}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x1430}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0204}, 
  {0x0F12, 0x1504}, 
  {0x0F12, 0x030F}, 
  {0x0F12, 0x0003}, 
  {0x0F12, 0x0902}, 
  {0x0F12, 0x2004}, 
  {0x0F12, 0x0050}, 
  {0x0F12, 0x1140}, 
  {0x0F12, 0x201C}, 
  {0x0F12, 0x0620}, 
  {0x0F12, 0x0306}, 
  {0x0F12, 0x2003}, 
  {0x0F12, 0xFF01}, 
  {0x0F12, 0x0404}, 
  {0x0F12, 0x0300}, 
  {0x0F12, 0x145A}, 
  {0x0F12, 0x1010}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x1000}, 
  {0x0F12, 0x5A0F}, 
  {0x0F12, 0x0503}, 
  {0x0F12, 0x1802}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2006}, 
  {0x0F12, 0x3C28}, 
  {0x0F12, 0x042C}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0xFF00}, 
  {0x0F12, 0x0904}, 
  {0x0F12, 0x4008}, 
  {0x0F12, 0x0540}, 
  {0x0F12, 0x8006}, 
  {0x0F12, 0x0020}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x1E10}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0405}, 
  {0x0F12, 0x0206}, 
  {0x0F12, 0x0304}, 
  {0x0F12, 0x0409}, 
  {0x0F12, 0x0305}, 
  {0x0F12, 0x0406}, 
  {0x0F12, 0x2804}, 
  {0x0F12, 0x0228}, 
  {0x0F12, 0x1402}, 
  {0x0F12, 0x0618}, 
  {0x0F12, 0x1A02}, 
  {0x0F12, 0x8018}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x0180}, 
  {0x0F12, 0x0A0A}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0F15}, 
  {0x0F12, 0x6024}, 
  {0x0F12, 0x0A0A}, 
  {0x0F12, 0xFFFF}, 
  {0x0F12, 0x0808}, 
  {0x0F12, 0x0A01}, 
  {0x0F12, 0x010A}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x2400}, 
  {0x0F12, 0x0260}, 
  {0x0F12, 0xFF02}, 
  {0x0F12, 0x40FF}, 
  {0x0F12, 0x0009}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x00C0}, 
  {0x0F12, 0x0064}, 
  {0x0F12, 0x0384}, 
  {0x0F12, 0x0032}, 
  {0x0F12, 0x01F4}, 
  {0x0F12, 0x0070}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x00A0}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0010}, 
  {0x0F12, 0x0060}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x1430}, 
  {0x0F12, 0x0201}, 
  {0x0F12, 0x0204}, 
  {0x0F12, 0x0F04}, 
  {0x0F12, 0x030C}, 
  {0x0F12, 0x0003}, 
  {0x0F12, 0x0602}, 
  {0x0F12, 0x1803}, 
  {0x0F12, 0x0040}, 
  {0x0F12, 0x0E20}, 
  {0x0F12, 0x2018}, 
  {0x0F12, 0x0620}, 
  {0x0F12, 0x0306}, 
  {0x0F12, 0x2003}, 
  {0x0F12, 0xFF01}, 
  {0x0F12, 0x0404}, 
  {0x0F12, 0x0200}, 
  {0x0F12, 0x145A}, 
  {0x0F12, 0x1010}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x1200}, 
  {0x0F12, 0x5A0F}, 
  {0x0F12, 0x0502}, 
  {0x0F12, 0x1802}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2006}, 
  {0x0F12, 0x4028}, 
  {0x0F12, 0x0430}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0xFF00}, 
  {0x0F12, 0x0804}, 
  {0x0F12, 0x4008}, 
  {0x0F12, 0x0540}, 
  {0x0F12, 0x8006}, 
  {0x0F12, 0x0020}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x2000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x1E10}, 
  {0x0F12, 0x000B}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x0607}, 
  {0x0F12, 0x0405}, 
  {0x0F12, 0x0205}, 
  {0x0F12, 0x0304}, 
  {0x0F12, 0x0409}, 
  {0x0F12, 0x0306}, 
  {0x0F12, 0x0407}, 
  {0x0F12, 0x2C04}, 
  {0x0F12, 0x022C}, 
  {0x0F12, 0x1402}, 
  {0x0F12, 0x0618}, 
  {0x0F12, 0x1A02}, 
  {0x0F12, 0x8018}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x0080}, 
  {0x0F12, 0x0180}, 
  {0x0F12, 0x0A0A}, 
  {0x0F12, 0x0101}, 
  {0x0F12, 0x0C0F}, 
  {0x0F12, 0x6024}, 
  {0x0F12, 0x0808}, 
  {0x0F12, 0xFFFF}, 
  {0x0F12, 0x0808}, 
  {0x0F12, 0x0A01}, 
  {0x0F12, 0x010A}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x2400}, 
  {0x0F12, 0x0060}, 
  {0x0F12, 0xFF00}, 
  {0x0F12, 0x40FF}, 
  {0x0F12, 0x0009}, 
  {0x0F12, 0x0001}, 
  
  {0x0F12, 0x23CE}, 
  {0x0F12, 0xFDC8}, 
  {0x0F12, 0x112E}, 
  {0x0F12, 0x93A5}, 
  {0x0F12, 0xFE67}, 
  {0x0F12, 0x0000}, 
  
  {0x002A, 0x01F8},
  {0x0F12, 0x5DC0}, 
  {0x002A, 0x0212},
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0002}, 
  {0x0F12, 0x0002}, 
  

  {0x002A, 0x021A},
  {0x0F12, 0x3A98}, 
  {0x0F12, 0x278D}, 
  {0x0F12, 0x278D}, 
  
  {0x0F12, 0x4F1A}, 
  {0x0F12, 0x278D}, 
  {0x0F12, 0x278D}, 
  
  {0x002A, 0x022C},
  {0x0F12, 0x0001}, 
  
  
  {0x002A, 0x02A6},
  {0x0F12, 0x0280}, 
  {0x0F12, 0x01E0}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x278D}, 
  {0x0F12, 0x278D}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0300}, 
  {0x0F12, 0x0002}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x01E0}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x03E8}, 
  {0x0F12, 0x014A}, 
  {0x002A, 0x02D0},
  {0x0F12, 0x0002}, 
  {0x0F12, 0x0002}, 
  
  {0x002A, 0x0396},
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0A00}, 
  {0x0F12, 0x0780}, 
  {0x0F12, 0x0005}, 
  {0x0F12, 0x278D}, 
  {0x0F12, 0x278D}, 
  {0x0F12, 0x0100}, 
  {0x0F12, 0x0300}, 
  {0x0F12, 0x0002}, 
  {0x0F12, 0x0070}, 
  {0x0F12, 0x0810}, 
  {0x0F12, 0x0900}, 
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0000}, 
  {0x0F12, 0x0002}, 
  {0x0F12, 0x07d0}, 
  {0x0F12, 0x07d0}, 
  
  
  
  

  {0x0028, 0x7000},//many insert
  {0x002A, 0x0266},
  {0x0F12, 0x0000}, 
  {0x002A, 0x026A},
  {0x0F12, 0x0001}, 
  {0x002A, 0x024E},
  {0x0F12, 0x0001}, 
  {0x002A, 0x0268},
  {0x0F12, 0x0001}, 
  {0x002A, 0x0270},
  {0x0F12, 0x0001}, 
  {0x002A, 0x023E},
  {0x0F12, 0x0001}, 
  {0x0F12, 0x0001}, 

  {0x002A,  0x01A8},
  {0x0F12,  0xAAAA},
  
  {0x0028,  0x147C},
  {0x002A,  0x01AA},
  {0x0F12,  0x0180}, 
  {0x0028,  0x1482},
  {0x002A,  0x01AC},
  {0x0F12,  0x0180}, 
  
};

#if 0
static struct regval_list sensor_qsxga_regs[] = {
  /* capture setting */
  
  {0x002A, 0x0396},
  {0x0F12, 0x0001},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x002A, 0x03AE},
  {0x0F12, 0x0000},
  {0x002A, 0x03B4},
  {0x0F12, 0x07D0},
  {0x0F12, 0x07D0},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x026E},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x002A, 0x0242},
  {0x0F12, 0x0001},
  {0x002A, 0x024E},
  {0x0F12, 0x0001},
  {0x002A, 0x0244},
  {0x0F12, 0x0001},
  
  {0xffff, 0x00c8}, 
};


#else
static struct regval_list sensor_qsxga_regs[] = {
  /* capture setting */

  {0x002A, 0x0396},
  {0x0F12, 0x0001},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x002A, 0x03AE},
  {0x0F12, 0x0000},
  {0x002A, 0x03B4},
  {0x0F12, 0x0535},
  {0x0F12, 0x0535},

  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x026E},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x002A, 0x0242},
  {0x0F12, 0x0001},
  {0x002A, 0x024E},
  {0x0F12, 0x0001},
  {0x002A, 0x0244},
  {0x0F12, 0x0001},

  {0xffff, 0x00c8}, 
};
#endif

static struct regval_list sensor_qxga_regs[] = {
  /* capture setting */
  
  {0x002A, 0x0396},
  {0x0F12, 0x0001},
  {0x0F12, 0x0800},
  {0x0F12, 0x0600},
  {0x002A, 0x03AE},
  {0x0F12, 0x0000},
  {0x002A, 0x03B4},
  {0x0F12, 0x0535},
  {0x0F12, 0x0535},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x026E},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x002A, 0x0242},
  {0x0F12, 0x0001},
  {0x002A, 0x024E},
  {0x0F12, 0x0001},
  {0x002A, 0x0244},
  {0x0F12, 0x0001},
  
  {0xffff, 0x00c8}, 
};


static struct regval_list sensor_1080p_regs[] = {
  /* preview setting */
  
  {0x002A, 0x18AC},
  {0x0F12, 0x0060},
  {0x0F12, 0x0060},
  {0x0F12, 0x05C0},
  {0x0F12, 0x0A96},
  
  {0x002A, 0x0250},
  {0x0F12, 0x0780},
  {0x0F12, 0x0438},
  {0x0F12, 0x014E},
  {0x0F12, 0x01B0},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0010},
  {0x0F12, 0x000C},
  
  {0x002A, 0x0494},
  {0x0F12, 0x0780},
  {0x0F12, 0x0438},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  
  {0x002A, 0x0262},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02A6},
  {0x0F12, 0x0780},
  {0x0F12, 0x0438},
  {0x002A, 0x02BC},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  {0x0F12, 0x0000},
  {0x0F12, 0x029A},
  {0x0F12, 0x029A},
  
  {0x002A, 0x022C},
  {0x0F12, 0x0001},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x0266},
  {0x0f12, 0x0000},
  {0x002A, 0x026A},
  {0x0F12, 0x0001},
  {0x002A, 0x0268},
  {0x0F12, 0x0001},
  {0x002A, 0x026E},
  {0x0f12, 0x0000},      
  {0x002A, 0x026A},
  {0x0F12, 0x0001},
  {0x002A, 0x0270},
  {0x0F12, 0x0001},
  
  {0x002A, 0x024E},
  {0x0F12, 0x0001},
  {0x002A, 0x023E},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  
  
  {0xffff, 0x00c8}, 
};

static struct regval_list sensor_720p_regs[] = {
  /* preview setting */
  
  {0x002A, 0x18AC},
  {0x0F12, 0x0060},
  {0x0F12, 0x0060},
  {0x0F12, 0x05C0},
  {0x0F12, 0x0A96},
  
  {0x002A, 0x0250},
  {0x0F12, 0x0A00},
  {0x0F12, 0x05A0},
  {0x0F12, 0x0010},
  {0x0F12, 0x00FC},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0010},
  {0x0F12, 0x000C},
  
  {0x002A, 0x0494},
  {0x0F12, 0x0A00},
  {0x0F12, 0x05A0},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  
  {0x002A, 0x0262},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02A6},
  {0x0F12, 0x0500},
  {0x0F12, 0x02D0},
  {0x002A, 0x02BC},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  {0x0F12, 0x014D},
  {0x0F12, 0x014D},
  
  {0x002A, 0x022C},
  {0x0F12, 0x0001},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x0266},
  {0x0f12, 0x0000},
  {0x002A, 0x026A},
  {0x0F12, 0x0001},
  {0x002A, 0x0268},
  {0x0F12, 0x0001},
  {0x002A, 0x026E},
  {0x0f12, 0x0000},      
  {0x002A, 0x026A},
  {0x0F12, 0x0001},
  {0x002A, 0x0270},
  {0x0F12, 0x0001},
  
  {0x002A, 0x024E},
  {0x0F12, 0x0001},
  {0x002A, 0x023E},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  
  {0xffff, 0x00c8}, 
};

static struct regval_list sensor_vga_regs[] = {
  #if 0 
  /* preview setting */
  
  {0x002A, 0x18AC},
  {0x0F12, 0x0060},
  {0x0F12, 0x0060},
  {0x0F12, 0x05C0},
  {0x0F12, 0x05C0},
  
  {0x002A, 0x0250},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0010},
  {0x0F12, 0x000C},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0010},
  {0x0F12, 0x000C},
  
  {0x002A, 0x0494},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  
  {0x002A, 0x0262},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02A6},
  {0x0F12, 0x0280},
  {0x0F12, 0x01E0},
  {0x002A, 0x02BC},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0001},
  {0x0F12, 0x0535},
  {0x0F12, 0x014D},
  
  {0x002A, 0x022C},
  {0x0F12, 0x0001},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x0266},
  {0x0f12, 0x0000},
  {0x002A, 0x026A},
  {0x0F12, 0x0001},
  {0x002A, 0x0268},
  {0x0F12, 0x0001},
  {0x002A, 0x026E},
  {0x0f12, 0x0000},      
  {0x002A, 0x026A},
  {0x0F12, 0x0001},
  {0x002A, 0x0270},
  {0x0F12, 0x0001},
  
  {0x002A, 0x024E},
  {0x0F12, 0x0001},
  {0x002A, 0x023E},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  
  {0xffff, 0x00c8}, 
  #else    
  /* preview setting */
  
  {0x002A, 0x18AC},
  {0x0F12, 0x0060},
  {0x0F12, 0x0060},
  {0x0F12, 0x05C0},
  {0x0F12, 0x05C0},
  
  {0x002A, 0x0250},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0010},
  {0x0F12, 0x000C},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0010},
  {0x0F12, 0x000C},
  
  {0x002A, 0x0494},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  {0x0F12, 0x0A00},
  {0x0F12, 0x0780},
  {0x0F12, 0x0000},
  {0x0F12, 0x0000},
  
  {0x002A, 0x0262},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02A6},
  {0x0F12, 0x0280},
  {0x0F12, 0x01E0},
  {0x002A, 0x02BC},
  {0x0F12, 0x0000},
  {0x0F12, 0x0002},
  {0x0F12, 0x0001},
  {0x0F12, 0x014D},
  {0x0F12, 0x0000},
  
  {0x0028, 0x7000},
  {0x002A, 0x0266},
  {0x0f12, 0x0000},
  {0x002A, 0x026A},
  {0x0F12, 0x0001},
  {0x002A, 0x0268},
  {0x0F12, 0x0001},
  {0x002A, 0x026E},
  {0x0f12, 0x0000},
  {0x002A, 0x026A},
  {0x0F12, 0x0001},
  {0x002A, 0x0270},
  {0x0F12, 0x0001},
  
  {0x002A, 0x024E},
  {0x0F12, 0x0001},
  {0x002A, 0x023E},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
  
  #endif
  
};

#if 0
static struct regval_list sensor_oe_disable_regs[] = {
};
#endif


#if 0
static struct regval_list sensor_af_fw_regs[] = {
};
#endif

static struct regval_list sensor_ae_awb_lockon_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x2C5E},
  {0x0F12, 0x0000},
};

static struct regval_list sensor_ae_awb_lockoff_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x2C5E},
  {0x0F12, 0x0001},
};

static struct regval_list sensor_af_single_trig_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x028E},
  {0x0F12, 0x0000},
  {0x002A, 0x028C},
  {0x0F12, 0x0005},
};

static struct regval_list sensor_af_continueous_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x028E},
  {0x0F12, 0x0000},
  {0x002A, 0x028C},
  {0x0F12, 0x0006},
};

static struct regval_list sensor_af_infinity_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x028E},
  {0x0F12, 0x0000},
  {0x002A, 0x028C},
  {0x0F12, 0x0004},
  

  {0x002A, 0x1648},
  {0x0F12, 0x9002},
};




/*
 * The white balance settings
 * Here only tune the R G B channel gain.
 * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
 */
static struct regval_list sensor_wb_manual[] = {
};

static struct regval_list sensor_wb_auto_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x04E6},
  {0x0F12, 0x077F},
};

static struct regval_list sensor_wb_incandescence_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x04E6},
  {0x0F12, 0x0777},
  {0x002A, 0x04BA},
  {0x0F12, 0x0430},
  {0x002A, 0x04BE},
  {0x0F12, 0x03D0},
  {0x002A, 0x04C2},
  {0x0F12, 0x09F0},
  {0x002A, 0x04C6},
  {0x0F12, 0x0001},
};

static struct regval_list sensor_wb_fluorescent_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x04E6},
  {0x0F12, 0x0777},
  {0x002A, 0x04BA},
  {0x0F12, 0x06C0},
  {0x002A, 0x04BE},
  {0x0F12, 0x0440},
  {0x002A, 0x04C2},
  {0x0F12, 0x07A0},
  {0x002A, 0x04C6},
  {0x0F12, 0x0001},
};

static struct regval_list sensor_wb_tungsten_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x04E6},
  {0x0F12, 0x0777},
  {0x002A, 0x04BA},
  {0x0F12, 0x0540},
  {0x002A, 0x04BE},
  {0x0F12, 0x03D0},
  {0x002A, 0x04C2},
  {0x0F12, 0x08F0},
  {0x002A, 0x04C6},
  {0x0F12, 0x0001},
};

static struct regval_list sensor_wb_horizon[] = {
};

static struct regval_list sensor_wb_daylight_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x04E6},
  {0x0F12, 0x0777},
  {0x002A, 0x04BA},
  {0x0F12, 0x0620},
  {0x002A, 0x04BE},
  {0x0F12, 0x03D0},
  {0x002A, 0x04C2},
  {0x0F12, 0x0580},
  {0x002A, 0x04C6},
  {0x0F12, 0x0001},
};

static struct regval_list sensor_wb_flash[] = {
};

static struct regval_list sensor_wb_cloud_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x04E6},
  {0x0F12, 0x0777},
  {0x002A, 0x04BA},
  {0x0F12, 0x06D0},
  {0x002A, 0x04BE},
  {0x0F12, 0x03D0},
  {0x002A, 0x04C2},
  {0x0F12, 0x0520},
  {0x002A, 0x04C6},
  {0x0F12, 0x0001},
};

static struct regval_list sensor_wb_shade[] = {
};

static struct cfg_array sensor_wb[] = {
  {
    .regs = sensor_wb_manual,            
    .size = ARRAY_SIZE (sensor_wb_manual),
  },
  {
    .regs = sensor_wb_auto_regs,         
    .size = ARRAY_SIZE (sensor_wb_auto_regs),
  },
  {
    .regs = sensor_wb_incandescence_regs,
    .size = ARRAY_SIZE (sensor_wb_incandescence_regs),
  },
  {
    .regs = sensor_wb_fluorescent_regs,  
    .size = ARRAY_SIZE (sensor_wb_fluorescent_regs),
  },
  {
    .regs = sensor_wb_tungsten_regs,     
    .size = ARRAY_SIZE (sensor_wb_tungsten_regs),
  },
  {
    .regs = sensor_wb_horizon,           
    .size = ARRAY_SIZE (sensor_wb_horizon),
  },
  {
    .regs = sensor_wb_daylight_regs,     
    .size = ARRAY_SIZE (sensor_wb_daylight_regs),
  },
  {
    .regs = sensor_wb_flash,             
    .size = ARRAY_SIZE (sensor_wb_flash),
  },
  {
    .regs = sensor_wb_cloud_regs,        
    .size = ARRAY_SIZE (sensor_wb_cloud_regs),
  },
  {
    .regs = sensor_wb_shade,             
    .size = ARRAY_SIZE (sensor_wb_shade),
  },
};


/*
 * The color effect settings
 */
static struct regval_list sensor_colorfx_none_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023C},
  {0x0F12, 0x0000},
};

static struct regval_list sensor_colorfx_bw_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023C},
  {0x0F12, 0x0001},
};

static struct regval_list sensor_colorfx_sepia_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023C},
  {0x0F12, 0x0004},
};

static struct regval_list sensor_colorfx_negative_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023C},
  {0x0F12, 0x0003},
};

static struct regval_list sensor_colorfx_emboss_regs[] = {

};

static struct regval_list sensor_colorfx_sketch_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023C},
  {0x0F12, 0x0009},
};

static struct regval_list sensor_colorfx_sky_blue_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023C},
  {0x0F12, 0x0007},
};

static struct regval_list sensor_colorfx_grass_green_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023C},
  {0x0F12, 0x0009},
};

static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
};

static struct regval_list sensor_colorfx_vivid_regs[] = {
};

static struct regval_list sensor_colorfx_aqua_regs[] = {
};

static struct regval_list sensor_colorfx_art_freeze_regs[] = {
};

static struct regval_list sensor_colorfx_silhouette_regs[] = {
};

static struct regval_list sensor_colorfx_solarization_regs[] = {
};

static struct regval_list sensor_colorfx_antique_regs[] = {
};

static struct regval_list sensor_colorfx_set_cbcr_regs[] = {
};

static struct cfg_array sensor_colorfx[] = {
  {
    .regs = sensor_colorfx_none_regs,        
    .size = ARRAY_SIZE (sensor_colorfx_none_regs),
  },
  {
    .regs = sensor_colorfx_bw_regs,          
    .size = ARRAY_SIZE (sensor_colorfx_bw_regs),
  },
  {
    .regs = sensor_colorfx_sepia_regs,       
    .size = ARRAY_SIZE (sensor_colorfx_sepia_regs),
  },
  {
    .regs = sensor_colorfx_negative_regs,    
    .size = ARRAY_SIZE (sensor_colorfx_negative_regs),
  },
  {
    .regs = sensor_colorfx_emboss_regs,      
    .size = ARRAY_SIZE (sensor_colorfx_emboss_regs),
  },
  {
    .regs = sensor_colorfx_sketch_regs,      
    .size = ARRAY_SIZE (sensor_colorfx_sketch_regs),
  },
  {
    .regs = sensor_colorfx_sky_blue_regs,    
    .size = ARRAY_SIZE (sensor_colorfx_sky_blue_regs),
  },
  {
    .regs = sensor_colorfx_grass_green_regs, 
    .size = ARRAY_SIZE (sensor_colorfx_grass_green_regs),
  },
  {
    .regs = sensor_colorfx_skin_whiten_regs, 
    .size = ARRAY_SIZE (sensor_colorfx_skin_whiten_regs),
  },
  {
    .regs = sensor_colorfx_vivid_regs,       
    .size = ARRAY_SIZE (sensor_colorfx_vivid_regs),
  },
  {
    .regs = sensor_colorfx_aqua_regs,        
    .size = ARRAY_SIZE (sensor_colorfx_aqua_regs),
  },
  {
    .regs = sensor_colorfx_art_freeze_regs,  
    .size = ARRAY_SIZE (sensor_colorfx_art_freeze_regs),
  },
  {
    .regs = sensor_colorfx_silhouette_regs,  
    .size = ARRAY_SIZE (sensor_colorfx_silhouette_regs),
  },
  {
    .regs = sensor_colorfx_solarization_regs,
    .size = ARRAY_SIZE (sensor_colorfx_solarization_regs),
  },
  {
    .regs = sensor_colorfx_antique_regs,     
    .size = ARRAY_SIZE (sensor_colorfx_antique_regs),
  },
  {
    .regs = sensor_colorfx_set_cbcr_regs,    
    .size = ARRAY_SIZE (sensor_colorfx_set_cbcr_regs),
  },
};

/*
 * The power frequency
 */
static struct regval_list sensor_flicker_50hz_regs[] = {
  {0x002A, 0x04E6},
  {0x0F12, 0x075F},
  {0x002a, 0x04d6},
  {0x0F12, 0x0001},
  {0x0F12, 0x0001},
};

static struct regval_list sensor_flicker_60hz_regs[] = {
  {0x002A, 0x04E6},
  {0x0F12, 0x075F},
  {0x002a, 0x04d6},
  {0x0f12, 0x0002},
  {0x0F12, 0x0001},
};

/*
 * The brightness setttings
 */
static struct regval_list sensor_brightness_neg4_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x0024},
};

static struct regval_list sensor_brightness_neg3_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x002A},
};

static struct regval_list sensor_brightness_neg2_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x0030},
};

static struct regval_list sensor_brightness_neg1_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x0036},
};

static struct regval_list sensor_brightness_zero_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x003C},
};

static struct regval_list sensor_brightness_pos1_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x0047},
};

static struct regval_list sensor_brightness_pos2_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x0052},
};

static struct regval_list sensor_brightness_pos3_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x0057},
};

static struct regval_list sensor_brightness_pos4_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x1484},
  {0x0F12, 0x0068},
};

static struct cfg_array sensor_brightness[] = {
  {
    .regs = sensor_brightness_neg4_regs,
    .size = ARRAY_SIZE (sensor_brightness_neg4_regs),
  },
  {
    .regs = sensor_brightness_neg3_regs,
    .size = ARRAY_SIZE (sensor_brightness_neg3_regs),
  },
  {
    .regs = sensor_brightness_neg2_regs,
    .size = ARRAY_SIZE (sensor_brightness_neg2_regs),
  },
  {
    .regs = sensor_brightness_neg1_regs,
    .size = ARRAY_SIZE (sensor_brightness_neg1_regs),
  },
  {
    .regs = sensor_brightness_zero_regs,
    .size = ARRAY_SIZE (sensor_brightness_zero_regs),
  },
  {
    .regs = sensor_brightness_pos1_regs,
    .size = ARRAY_SIZE (sensor_brightness_pos1_regs),
  },
  {
    .regs = sensor_brightness_pos2_regs,
    .size = ARRAY_SIZE (sensor_brightness_pos2_regs),
  },
  {
    .regs = sensor_brightness_pos3_regs,
    .size = ARRAY_SIZE (sensor_brightness_pos3_regs),
  },
  {
    .regs = sensor_brightness_pos4_regs,
    .size = ARRAY_SIZE (sensor_brightness_pos4_regs),
  },
};

/*
 * The contrast setttings
 */
static struct regval_list sensor_contrast_neg4_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0xFF80},  
};

static struct regval_list sensor_contrast_neg3_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0xFFA0},  
};

static struct regval_list sensor_contrast_neg2_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0xFFC0},  
};

static struct regval_list sensor_contrast_neg1_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0xFFE0},  
};

static struct regval_list sensor_contrast_zero_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0x0000},  
};

static struct regval_list sensor_contrast_pos1_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0x0020},  
};

static struct regval_list sensor_contrast_pos2_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0x0040},  
};

static struct regval_list sensor_contrast_pos3_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0x0060},  
};

static struct regval_list sensor_contrast_pos4_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0232},
  {0x0F12, 0x0080},  
};

static struct cfg_array sensor_contrast[] = {
  {
    .regs = sensor_contrast_neg4_regs,
    .size = ARRAY_SIZE (sensor_contrast_neg4_regs),
  },
  {
    .regs = sensor_contrast_neg3_regs,
    .size = ARRAY_SIZE (sensor_contrast_neg3_regs),
  },
  {
    .regs = sensor_contrast_neg2_regs,
    .size = ARRAY_SIZE (sensor_contrast_neg2_regs),
  },
  {
    .regs = sensor_contrast_neg1_regs,
    .size = ARRAY_SIZE (sensor_contrast_neg1_regs),
  },
  {
    .regs = sensor_contrast_zero_regs,
    .size = ARRAY_SIZE (sensor_contrast_zero_regs),
  },
  {
    .regs = sensor_contrast_pos1_regs,
    .size = ARRAY_SIZE (sensor_contrast_pos1_regs),
  },
  {
    .regs = sensor_contrast_pos2_regs,
    .size = ARRAY_SIZE (sensor_contrast_pos2_regs),
  },
  {
    .regs = sensor_contrast_pos3_regs,
    .size = ARRAY_SIZE (sensor_contrast_pos3_regs),
  },
  {
    .regs = sensor_contrast_pos4_regs,
    .size = ARRAY_SIZE (sensor_contrast_pos4_regs),
  },
};

/*
 * The saturation setttings
 */
static struct regval_list sensor_saturation_neg4_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0xFF80},  
};

static struct regval_list sensor_saturation_neg3_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0xFFA0},  
};

static struct regval_list sensor_saturation_neg2_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0xFFC0},  
};

static struct regval_list sensor_saturation_neg1_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0xFFE0},  
};

static struct regval_list sensor_saturation_zero_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0x0000},  
};

static struct regval_list sensor_saturation_pos1_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0x0020},  
};

static struct regval_list sensor_saturation_pos2_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0x0040},  
};

static struct regval_list sensor_saturation_pos3_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0x0060},  
};

static struct regval_list sensor_saturation_pos4_regs[] = {
  {0x0028, 0x7000},
  {0x002A, 0x0234},
  {0x0F12, 0x0080},  
};

static struct cfg_array sensor_saturation[] = {
  {
    .regs = sensor_saturation_neg4_regs,
    .size = ARRAY_SIZE (sensor_saturation_neg4_regs),
  },
  {
    .regs = sensor_saturation_neg3_regs,
    .size = ARRAY_SIZE (sensor_saturation_neg3_regs),
  },
  {
    .regs = sensor_saturation_neg2_regs,
    .size = ARRAY_SIZE (sensor_saturation_neg2_regs),
  },
  {
    .regs = sensor_saturation_neg1_regs,
    .size = ARRAY_SIZE (sensor_saturation_neg1_regs),
  },
  {
    .regs = sensor_saturation_zero_regs,
    .size = ARRAY_SIZE (sensor_saturation_zero_regs),
  },
  {
    .regs = sensor_saturation_pos1_regs,
    .size = ARRAY_SIZE (sensor_saturation_pos1_regs),
  },
  {
    .regs = sensor_saturation_pos2_regs,
    .size = ARRAY_SIZE (sensor_saturation_pos2_regs),
  },
  {
    .regs = sensor_saturation_pos3_regs,
    .size = ARRAY_SIZE (sensor_saturation_pos3_regs),
  },
  {
    .regs = sensor_saturation_pos4_regs,
    .size = ARRAY_SIZE (sensor_saturation_pos4_regs),
  },
};

/*
 * The exposure target setttings
 */
static struct regval_list sensor_ev_neg4_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x0080},  
};

static struct regval_list sensor_ev_neg3_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x00A0},  
};

static struct regval_list sensor_ev_neg2_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x00C0},  
};

static struct regval_list sensor_ev_neg1_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x00E0},  
};

static struct regval_list sensor_ev_zero_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x0100},  
};

static struct regval_list sensor_ev_pos1_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x0120},  
};

static struct regval_list sensor_ev_pos2_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x0140},  
};

static struct regval_list sensor_ev_pos3_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x0160},  
};

static struct regval_list sensor_ev_pos4_regs[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x023A},
  {0x0F12, 0x0180},  
};

static struct cfg_array sensor_ev[] = {
  {
    .regs = sensor_ev_neg4_regs,
    .size = ARRAY_SIZE (sensor_ev_neg4_regs),
  },
  {
    .regs = sensor_ev_neg3_regs,
    .size = ARRAY_SIZE (sensor_ev_neg3_regs),
  },
  {
    .regs = sensor_ev_neg2_regs,
    .size = ARRAY_SIZE (sensor_ev_neg2_regs),
  },
  {
    .regs = sensor_ev_neg1_regs,
    .size = ARRAY_SIZE (sensor_ev_neg1_regs),
  },
  {
    .regs = sensor_ev_zero_regs,
    .size = ARRAY_SIZE (sensor_ev_zero_regs),
  },
  {
    .regs = sensor_ev_pos1_regs,
    .size = ARRAY_SIZE (sensor_ev_pos1_regs),
  },
  {
    .regs = sensor_ev_pos2_regs,
    .size = ARRAY_SIZE (sensor_ev_pos2_regs),
  },
  {
    .regs = sensor_ev_pos3_regs,
    .size = ARRAY_SIZE (sensor_ev_pos3_regs),
  },
  {
    .regs = sensor_ev_pos4_regs,
    .size = ARRAY_SIZE (sensor_ev_pos4_regs),
  },
};


/*
 * Here we'll try to encapsulate the changes for just the output
 * video format.
 *
 */
static struct regval_list sensor_fmt_mipi_yuv422[] = {


  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02B4},
  {0x0F12, 0x0040},
  {0x002A, 0x03A6},
  {0x0F12, 0x0040},
  
  
  
  
  
};

#if 0
static struct regval_list sensor_fmt_yuv422_yuyv[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02B4},
  {0x0F12, 0x0040},
  {0x002A, 0x03A6},
  {0x0F12, 0x0040},
  

};

static struct regval_list sensor_fmt_yuv422_yvyu[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02B4},
  {0x0F12, 0x0060},
  {0x002A, 0x03A6},
  {0x0F12, 0x0060},
  
};

static struct regval_list sensor_fmt_yuv422_vyuy[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02B4},
  {0x0F12, 0x0070},
  {0x002A, 0x03A6},
  {0x0F12, 0x0070},
  
};

static struct regval_list sensor_fmt_yuv422_uyvy[] = {
  {0xFCFC, 0xD000},
  {0x0028, 0x7000},
  {0x002A, 0x02B4},
  {0x0F12, 0x0050},
  {0x002A, 0x03A6},
  {0x0F12, 0x0050},
  
};
#endif



/*
 * Low-level register I/O.
 *
 */


/*
 * On most platforms, we'd rather do straight i2c I/O.
 */
static int sensor_read (struct v4l2_subdev * sd, unsigned short reg,
                        unsigned short * value)
{
  int ret = 0;
  int cnt = 0;
  
  ret = cci_read_a16_d16 (sd, reg, value);
  while (ret != 0 && cnt < 2)
  {
    ret = cci_read_a16_d16 (sd, reg, value);
    cnt++;
  }
  if (cnt > 0)
  { vfe_dev_dbg ("sensor read retry=%d\n", cnt); }
  
  return ret;
}

static int sensor_write (struct v4l2_subdev * sd, unsigned short reg,
                         unsigned short value)
{
  int ret = 0;
  int cnt = 0;
  
  ret = cci_write_a16_d16 (sd, reg, value);
  while (ret != 0 && cnt < 2)
  {
    ret = cci_write_a16_d16 (sd, reg, value);
    cnt++;
  }
  if (cnt > 0)
  { vfe_dev_dbg ("sensor write retry=%d\n", cnt); }
  
  return ret;
}

/*
 * Write a list of register settings;
 */
static int sensor_write_array (struct v4l2_subdev * sd, struct regval_list * regs, int array_size)
{
  int i = 0;
  
  if (!regs)
  { return -EINVAL; }
  
  while (i < array_size)
  {
    if (regs->addr == REG_DLY) {
      msleep (regs->data);
    }
    else {
      LOG_ERR_RET (sensor_write (sd, regs->addr, regs->data) )
    }
    i++;
    regs++;
  }
  return 0;
}

static int sensor_g_hflip (struct v4l2_subdev * sd, __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  
  *value = info->hflip;
  return 0;
}

static int sensor_s_hflip (struct v4l2_subdev * sd, int value)
{
  int ret;
  struct sensor_info * info = to_state (sd);
  unsigned short pre_val, cap_val;
  struct regval_list regs[] = {
    
    {0xFCFC, 0xD000},
    {0x0028, 0x7000},
    {0x002A, 0x0266},
    {0x0f12, 0x0000},
    {0x002A, 0x026A},
    {0x0F12, 0x0001},
    {0x002A, 0x024E},
    {0x0F12, 0x0001},
    {0x002A, 0x0268},
    {0x0F12, 0x0001},
    {0x002A, 0x023E},
    {0x0F12, 0x0001},
    {0x0F12, 0x0001},
  };
  
  if (info->hflip == value)
  { return 0; }
  
  sensor_write (sd, 0x002c , 0x7000);
  sensor_write (sd, 0x002e , 0x02d0);
  sensor_read (sd, 0x0f12, &pre_val);
  sensor_read (sd, 0x0f12, &cap_val);
  sensor_write (sd, 0x0028, 0x7000);
  sensor_write (sd, 0x002a, 0x02d0);
  
  switch (value) {
  case 0:
    pre_val &= 0xfa;
    cap_val &= 0xfa;
    break;
  case 1:
    pre_val |= 0x05;
    cap_val |= 0x05;
    break;
  default:
    return -EINVAL;
  }
  
  sensor_write (sd, 0x0f12, pre_val);
  sensor_write (sd, 0x0f12, cap_val);
  
  ret = sensor_write_array (sd, regs, ARRAY_SIZE (regs) );
  if (ret < 0) {
    vfe_dev_err ("sensor_write err at sensor_s_hflip!\n");
    return ret;
  }
  
  info->hflip = value;
  
  return 0;
}

static int sensor_g_vflip (struct v4l2_subdev * sd, __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  
  *value = info->vflip;
  return 0;
}

static int sensor_s_vflip (struct v4l2_subdev * sd, int value)
{
  int ret;
  struct sensor_info * info = to_state (sd);
  unsigned short pre_val, cap_val;
  struct regval_list regs[] = {
    
    {0xFCFC, 0xD000},
    {0x0028, 0x7000},
    {0x002A, 0x0266},
    {0x0f12, 0x0000},
    {0x002A, 0x026A},
    {0x0F12, 0x0001},
    {0x002A, 0x024E},
    {0x0F12, 0x0001},
    {0x002A, 0x0268},
    {0x0F12, 0x0001},
    {0x002A, 0x023E},
    {0x0F12, 0x0001},
    {0x0F12, 0x0001},
  };
  
  if (info->vflip == value)
  { return 0; }
  
  sensor_write (sd, 0x0028, 0x7000);
  sensor_write (sd, 0x002a, 0x02d0);
  sensor_write (sd, 0x002c , 0x7000);
  sensor_write (sd, 0x002e , 0x02d0);
  sensor_read (sd, 0x0f12, &pre_val);
  sensor_read (sd, 0x0f12, &cap_val);
  
  switch (value) {
  case 0:
    pre_val &= 0xf5;
    cap_val &= 0xf5;
    break;
  case 1:
    pre_val |= 0x0A;
    cap_val |= 0x0A;
    break;
  default:
    return -EINVAL;
  }
  
  sensor_write (sd, 0x0f12, pre_val);
  sensor_write (sd, 0x0f12, cap_val);
  
  ret = sensor_write_array (sd, regs, ARRAY_SIZE (regs) );
  if (ret < 0) {
    vfe_dev_err ("sensor_write err at sensor_s_vflip!\n");
    return ret;
  }
  
  info->vflip = value;
  
  return 0;
}

/* stuff about exposure when capturing image */

static int sensor_set_exposure (struct v4l2_subdev * sd)
{
  return 0;
}

/* stuff about auto focus */
static int sensor_download_af_fw (struct v4l2_subdev * sd)
{
  return 0;
}

static int sensor_ae_awb_lockon (struct v4l2_subdev * sd)
{
  int ret;
  
  ret = sensor_write_array (sd, sensor_ae_awb_lockon_regs , ARRAY_SIZE (sensor_ae_awb_lockon_regs) );
  if (ret < 0)
  { vfe_dev_err ("sensor_ae_awb_lockon error!\n"); }
  
  return ret;
};

static int sensor_ae_awb_lockoff (struct v4l2_subdev * sd)
{
  int ret;
  
  ret = sensor_write_array (sd, sensor_ae_awb_lockoff_regs , ARRAY_SIZE (sensor_ae_awb_lockoff_regs) );
  if (ret < 0)
  { vfe_dev_err ("sensor_ae_awb_lockoff error!\n"); }
  
  return ret;
};

static int sensor_s_single_af (struct v4l2_subdev * sd)
{
  int ret;
  struct sensor_info * info = to_state (sd);
  
  vfe_dev_print ("sensor_s_single_af\n");
  
  info->focus_status = 0;
  coarse_af_pd = 0;
  sensor_ae_awb_lockon (sd);
  
  ret = sensor_write_array (sd, sensor_af_single_trig_regs , ARRAY_SIZE (sensor_af_single_trig_regs) );
  if (ret < 0) {
    vfe_dev_err ("sensor_s_single_af error!\n");
    sensor_ae_awb_lockoff (sd);
  }
  else
    if (ret == 0) {
      info->focus_status = 1;
    }
    
  
  #if 0
  
  rdval = 0xffff;
  cnt = 0;
  while (rdval != 0x0002)
  {
    ret = sensor_write (sd, 0x002c , 0x7000);
    ret = sensor_write (sd, 0x002e , 0x2eee);
    if (ret < 0)
    {
      vfe_dev_err ("sensor_s_single_af error!\n");
      goto af_out;
    }
    ret =  sensor_read (sd, 0x0f12 , &rdval);
    if (ret < 0)
    {
      vfe_dev_err ("sensor_s_single_af read error !\n");
      goto af_out;
    }
    vfe_dev_dbg ("Single AF 1st ,value = 0x%4x\n", rdval);
    
    if (rdval != 0x0001 && rdval != 0x0002) {
      vfe_dev_err ("Single AF 1st is failed,value = 0x%4x\n", rdval);
      ret = -EFAULT;
      goto af_out;
    }
    else {
      usleep_range (15000, 20000);
      cnt++;
      if (cnt > 60) {
        vfe_dev_err ("Single AF 1st is timeout,value = 0x%4x\n", rdval);
        ret = -EFAULT;
        goto af_out;
      }
    }
  }
  vfe_dev_print ("Single AF 1st is complete,value = 0x%4x\n", rdval);
  
  rdval = 0xffff;
  cnt = 0;
  while ( (rdval & 0xff00) != 0x0000)
  {
    ret = sensor_write (sd, 0x002c , 0x7000);
    ret = sensor_write (sd, 0x002e , 0x2207);
    if (ret < 0)
    {
      vfe_dev_err ("sensor_s_single_af error!\n");
      goto af_out;
    }
    
    ret =  sensor_read (sd, 0x0f12 , &rdval);
    if (ret < 0)
    {
      vfe_dev_err ("sensor_s_single_af read error !\n");
      goto af_out;
    }
    usleep_range (5000, 10000);
    
    cnt++;
    if (cnt > 300) {
      vfe_dev_err ("Single AF 2nd is timeout,value = 0x%4x\n", rdval);
      ret = -EFAULT;
      goto af_out;
    }
  }
  vfe_dev_print ("Single AF 2nd is complete,value = 0x%4x\n", rdval);
  
af_out:
  sensor_ae_awb_lockoff (sd);
  #endif
  
  return ret;
}

static int sensor_g_single_af (struct v4l2_subdev * sd)
{
  unsigned short rdval;
  int ret;
  struct sensor_info * info = to_state (sd);
  
  vfe_dev_dbg ("sensor_g_single_af\n");
  vfe_dev_dbg ("coarse_af_pd = %d\n", coarse_af_pd);
  if (coarse_af_pd != 1) {
    rdval = 0xffff;
    sensor_write (sd, 0x002c , 0x7000);
    sensor_write (sd, 0x002e , 0x2eee);
    ret =  sensor_read (sd, 0x0f12 , &rdval);
    if (ret < 0)
    {
      vfe_dev_err ("sensor_g_single_af read error !\n");
      ret = -EAGAIN;
      goto af_out;
    }
    
    if (rdval == 0x0001 ) {
      vfe_dev_dbg ("Single AF 1st is busy,value = 0x%4x\n", rdval);
      msleep (50);
      coarse_af_pd = 0;
      return EBUSY;
    }
    else
      if (rdval == 0x0002) {
        coarse_af_pd = 1;
        vfe_dev_print ("Single AF 1st is complete,value = 0x%4x\n", rdval);
      }
      else {
        vfe_dev_print ("Single AF 1st is failed,value = 0x%4x\n", rdval);
        info->focus_status = 0;
        coarse_af_pd = 2;
        ret = EFAULT;
        goto af_out;
      }
  }
  
  rdval = 0xffff;
  sensor_write (sd, 0x002c , 0x7000);
  sensor_write (sd, 0x002e , 0x2207);
  ret =  sensor_read (sd, 0x0f12 , &rdval);
  if (ret < 0)
  {
    vfe_dev_err ("sensor_g_single_af read error !\n");
    goto af_out;
  }
  

  if ( (rdval & 0xff00) != 0x0000) {
    vfe_dev_dbg ("Single AF 2nd is busy,value = 0x%4x\n", rdval);
    return EBUSY;
  }
  
  vfe_dev_print ("Single AF 2nd is complete,value = 0x%4x\n", rdval);
  info->focus_status = 0;
  
  ret = 0;
af_out:

  sensor_ae_awb_lockoff (sd);
  
  return ret;
}

static int sensor_g_contin_af (struct v4l2_subdev * sd)
{



  return V4L2_AUTO_FOCUS_STATUS_IDLE;
}

static int sensor_g_af_status (struct v4l2_subdev * sd)
{
  int ret = 0;
  struct sensor_info * info = to_state (sd);
  
  if (info->auto_focus == 1)
  { ret = sensor_g_contin_af (sd); }
  else
  { ret = sensor_g_single_af (sd); }
  
  return ret;
}


static int sensor_s_init_af (struct v4l2_subdev * sd)
{
  int ret;
  struct sensor_info * info = to_state (sd);
  ret = sensor_download_af_fw (sd);
  if (ret == 0)
  { info->af_first_flag = 0; }
  return ret;
}

static int sensor_s_infinity_af (struct v4l2_subdev * sd)
{
  int ret;
  
  vfe_dev_print ("sensor_s_infinity_af\n");
  ret = sensor_write_array (sd, sensor_af_infinity_regs, ARRAY_SIZE (sensor_af_infinity_regs) );
  if (ret < 0)
  { vfe_dev_err ("sensor_s_infinity_af error\n"); }
  
  return ret;
}

static int sensor_s_pause_af (struct v4l2_subdev * sd)
{
  return 0;
}

static int sensor_s_release_af (struct v4l2_subdev * sd)
{
  return 0;
}

static int sensor_s_continueous_af (struct v4l2_subdev * sd, int value)
{
  int ret = 0;
  struct sensor_info * info = to_state (sd);
  
  vfe_dev_print ("sensor_s_continueous_af[0x%x]\n", value);
  
  if (value == 1)
  {
    ret = sensor_write_array (sd, sensor_af_continueous_regs, ARRAY_SIZE (sensor_af_continueous_regs) );
    if (ret < 0)
    { vfe_dev_err ("sensor_s_continueous_af error\n"); }
    info->auto_focus = 1;
  }
  else
  {
    LOG_ERR_RET (sensor_s_infinity_af (sd) );
    info->auto_focus = 0;
  }
  
  return ret;
}


static int sensor_s_af_zone (struct v4l2_subdev * sd,
                             struct v4l2_win_coordinate * win_c)
{
  struct sensor_info * info = to_state (sd);
  
  int x1, y1, x2, y2;
  unsigned int xc, yc;
  unsigned int prv_x, prv_y;
  
  int fst_win_start_x, fst_win_start_y;
  int fst_disp_start_x, fst_disp_start_y;
  int fst_win_size_x = 512, fst_win_size_y = 568;
  int fst_disp_size_x, fst_disp_size_y;
  int scnd_win_start_x, scnd_win_start_y;
  int scnd_disp_start_x, scnd_disp_start_y;
  int scnd_win_size_x = 116, scnd_win_size_y = 306;
  int scnd_disp_size_x, scnd_disp_size_y;
  
  if (info->focus_status == 1)
  { return 0; }
  
  if (info->width == 0 || info->height == 0) {
    vfe_dev_err ("current width or height is zero!\n");
    return -EINVAL;
  }
  vfe_dev_print ("sensor_s_af_zone\n");
  
  prv_x = (int) info->width;
  prv_y = (int) info->height;
  
  x1 = win_c->x1;
  y1 = win_c->y1;
  x2 = win_c->x2;
  y2 = win_c->y2;
  
  #ifdef AF_WIN_NEW_COORD
  xc = prv_x * ( (unsigned int) (2000 + x1 + x2) / 2) / 2000;
  yc = (prv_y * ( (unsigned int) (2000 + y1 + y2) / 2) / 2000);
  #else
  xc = (x1 + x2) / 2;
  yc = (y1 + y2) / 2;
  #endif
  vfe_dev_dbg ("af zone input xc=%d,yc=%d\n", xc, yc);
  
  
  fst_disp_size_x = fst_win_size_x * info->width / 1024;
  
  if (xc + fst_disp_size_x / 2 > info->width) {
    fst_disp_start_x = info->width - fst_disp_size_x;
  }
  else
    if (xc - (fst_disp_size_x / 2) < 0) {
      fst_disp_start_x = 0;
    }
    else {
      fst_disp_start_x = xc - (fst_disp_size_x / 2);
    }
    
  fst_disp_size_y = fst_win_size_y * info->height / 1024;
  if (yc + fst_disp_size_y / 2 > info->height) {
    fst_disp_start_y = info->height - fst_disp_size_y;
  }
  else
    if (yc - fst_disp_size_y / 2 < 0) {
      fst_disp_start_y = 0;
    }
    else {
      fst_disp_start_y = yc - fst_disp_size_y / 2;
    }
    
  fst_win_start_x = fst_disp_start_x * 1024 / info->width;
  fst_win_start_y = fst_disp_start_y * 1024 / info->height;
  
  
  scnd_disp_size_x = scnd_win_size_x * info->width / 1024;
  if (xc + scnd_disp_size_x / 2 > info->width) {
    scnd_disp_start_x = info->width - scnd_disp_size_x;
  }
  else
    if (xc - scnd_disp_size_x / 2 < 0) {
      scnd_disp_start_x = 0;
    }
    else {
      scnd_disp_start_x = xc - scnd_disp_size_x / 2;
    }
    
  scnd_disp_size_y = scnd_win_size_y * info->height / 1024;
  if (yc + scnd_disp_size_y / 2 > info->height) {
    scnd_disp_start_y = info->height - scnd_disp_size_y;
  }
  else
    if (yc - scnd_disp_size_y / 2 < 0) {
      scnd_disp_start_y = 0;
    }
    else {
      scnd_disp_start_y = yc - scnd_disp_size_y / 2;
    }
    
  scnd_win_start_x = scnd_disp_start_x * 1024 / info->width;
  scnd_win_start_y = scnd_disp_start_y * 1024 / info->height;
  
  sensor_write (sd, 0x0028, 0x7000);
  sensor_write (sd, 0x002a, 0x0294);
  sensor_write (sd, 0x0f12, fst_win_start_x);
  sensor_write (sd, 0x0f12, fst_win_start_y);
  sensor_write (sd, 0x0f12, fst_win_size_x); 
  sensor_write (sd, 0x0f12, fst_win_size_y); 
  sensor_write (sd, 0x0f12, scnd_win_start_x);
  sensor_write (sd, 0x0f12, scnd_win_start_y);
  sensor_write (sd, 0x0f12, scnd_win_size_x);
  sensor_write (sd, 0x0f12, scnd_win_size_y);
  sensor_write (sd, 0x0f12, 0x0001);         
  
  vfe_dev_dbg ("af zone 1st window stx=%d,sty=%d,width=%d,height=%d\n", fst_win_start_x, fst_win_start_y, fst_win_size_x, fst_win_size_y);
  vfe_dev_dbg ("af zone 2nd window stx=%d,sty=%d,width=%d,height=%d\n", scnd_win_start_x, scnd_win_start_y, scnd_win_size_x, scnd_win_size_y);
  
  usleep_range (30000, 31000);
  return 0;
}


#if 0
static int sensor_s_relaunch_af_zone (struct v4l2_subdev * sd)
{
  return 0;
}
#endif


static int sensor_g_autogain (struct v4l2_subdev * sd, __s32 * value)
{
  return -EINVAL;
}

static int sensor_s_autogain (struct v4l2_subdev * sd, int value)
{
  return -EINVAL;
}

static int sensor_g_autoexp (struct v4l2_subdev * sd, __s32 * value)
{
  return -EINVAL;
}

static int sensor_s_autoexp (struct v4l2_subdev * sd,
                             enum v4l2_exposure_auto_type value)
{
  return -EINVAL;
}

static int sensor_g_autowb (struct v4l2_subdev * sd, int * value)
{
  struct sensor_info * info = to_state (sd);
  
  *value = info->autowb;
  return 0;
}

static int sensor_s_autowb (struct v4l2_subdev * sd, int value)
{
  int ret;
  struct sensor_info * info = to_state (sd);
  
  ret = sensor_write_array (sd, sensor_wb_auto_regs, ARRAY_SIZE (sensor_wb_auto_regs) );
  if (ret < 0) {
    vfe_dev_err ("sensor_write_array err at sensor_s_autowb!\n");
    return ret;
  }
  
  usleep_range (10000, 12000);
  info->autowb = value;
  
  return 0;
}

static int sensor_g_hue (struct v4l2_subdev * sd, __s32 * value)
{
  return -EINVAL;
}

static int sensor_s_hue (struct v4l2_subdev * sd, int value)
{
  return -EINVAL;
}

static int sensor_g_gain (struct v4l2_subdev * sd, __s32 * value)
{
  return -EINVAL;
}

static int sensor_s_gain (struct v4l2_subdev * sd, int value)
{
  return -EINVAL;
}

static int sensor_g_band_filter (struct v4l2_subdev * sd,
                                 __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  
  *value = info->band_filter;
  return 0;
}

static int sensor_s_band_filter (struct v4l2_subdev * sd,
                                 enum v4l2_power_line_frequency value)
{
  struct sensor_info * info = to_state (sd);
  
  int ret = 0;
  
  switch (value) {
  case V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:
    break;
  case V4L2_CID_POWER_LINE_FREQUENCY_50HZ:
    ret = sensor_write_array (sd, sensor_flicker_50hz_regs, ARRAY_SIZE (sensor_flicker_50hz_regs) );
    if (ret < 0)
    { vfe_dev_err ("sensor_write_array err at sensor_s_band_filter!\n"); }
    break;
  case V4L2_CID_POWER_LINE_FREQUENCY_60HZ:
    ret = sensor_write_array (sd, sensor_flicker_60hz_regs, ARRAY_SIZE (sensor_flicker_60hz_regs) );
    if (ret < 0)
    { vfe_dev_err ("sensor_write_array err at sensor_s_band_filter!\n"); }
    break;
  case V4L2_CID_POWER_LINE_FREQUENCY_AUTO:
    break;
  }
  info->band_filter = value;
  return ret;
}

static int sensor_g_brightness (struct v4l2_subdev * sd, __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  
  *value = info->brightness;
  return 0;
}

static int sensor_s_brightness (struct v4l2_subdev * sd, int value)
{
  struct sensor_info * info = to_state (sd);
  
  if (info->brightness == value)
  { return 0; }
  
  if (value < -4 || value > 4)
  { return -ERANGE; }
  
  LOG_ERR_RET (sensor_write_array (sd, sensor_brightness[value + 4].regs, sensor_brightness[value + 4].size) )
  
  info->brightness = value;
  return 0;
}

static int sensor_g_contrast (struct v4l2_subdev * sd, __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  
  *value = info->contrast;
  return 0;
}

static int sensor_s_contrast (struct v4l2_subdev * sd, int value)
{
  struct sensor_info * info = to_state (sd);
  
  if (info->contrast == value)
  { return 0; }
  
  if (value < -4 || value > 4)
  { return -ERANGE; }
  
  LOG_ERR_RET (sensor_write_array (sd, sensor_contrast[value + 4].regs, sensor_contrast[value + 4].size) )
  
  info->contrast = value;
  return 0;
}

static int sensor_g_saturation (struct v4l2_subdev * sd, __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  
  *value = info->saturation;
  return 0;
}

static int sensor_s_saturation (struct v4l2_subdev * sd, int value)
{
  struct sensor_info * info = to_state (sd);
  
  if (info->saturation == value)
  { return 0; }
  
  if (value < -4 || value > 4)
  { return -ERANGE; }
  
  LOG_ERR_RET (sensor_write_array (sd, sensor_saturation[value + 4].regs, sensor_saturation[value + 4].size) )
  
  info->saturation = value;
  return 0;
}

static int sensor_g_exp_bias (struct v4l2_subdev * sd, __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  
  *value = info->exp_bias;
  return 0;
}

static int sensor_s_exp_bias (struct v4l2_subdev * sd, int value)
{
  struct sensor_info * info = to_state (sd);
  
  if (info->exp_bias == value)
  { return 0; }
  
  if (value < -4 || value > 4)
  { return -ERANGE; }
  
  LOG_ERR_RET (sensor_write_array (sd, sensor_ev[value + 4].regs, sensor_ev[value + 4].size) )
  
  info->exp_bias = value;
  return 0;
}

static int sensor_g_wb (struct v4l2_subdev * sd, int * value)
{
  struct sensor_info * info = to_state (sd);
  enum v4l2_auto_n_preset_white_balance * wb_type = (enum v4l2_auto_n_preset_white_balance *) value;
  
  *wb_type = info->wb;
  
  return 0;
}

static int sensor_s_wb (struct v4l2_subdev * sd,
                        enum v4l2_auto_n_preset_white_balance value)
{
  struct sensor_info * info = to_state (sd);
  
  if (info->capture_mode == V4L2_MODE_IMAGE)
  { return 0; }
  
  if (info->wb == value)
  { return 0; }
  
  LOG_ERR_RET (sensor_write_array (sd, sensor_wb[value].regs , sensor_wb[value].size) )
  
  if (value == V4L2_WHITE_BALANCE_AUTO)
  { info->autowb = 1; }
  else
  { info->autowb = 0; }
  
  info->wb = value;
  return 0;
}

static int sensor_g_colorfx (struct v4l2_subdev * sd,
                             __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  enum v4l2_colorfx * clrfx_type = (enum v4l2_colorfx *) value;
  
  *clrfx_type = info->clrfx;
  return 0;
}

static int sensor_s_colorfx (struct v4l2_subdev * sd,
                             enum v4l2_colorfx value)
{
  struct sensor_info * info = to_state (sd);
  
  if (info->clrfx == value)
  { return 0; }
  
  LOG_ERR_RET (sensor_write_array (sd, sensor_colorfx[value].regs, sensor_colorfx[value].size) )
  
  info->clrfx = value;
  return 0;
}

static int sensor_g_flash_mode (struct v4l2_subdev * sd,
                                __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  enum v4l2_flash_led_mode * flash_mode = (enum v4l2_flash_led_mode *) value;
  
  *flash_mode = info->flash_mode;
  return 0;
}

static int sensor_s_flash_mode (struct v4l2_subdev * sd,
                                enum v4l2_flash_led_mode value)
{
  struct sensor_info * info = to_state (sd);

  info->flash_mode = value;
  return 0;
}


/*
 * Stuff that knows about the sensor.
 */

static int sensor_power (struct v4l2_subdev * sd, int on)
{
  
  switch (on)
  {
  case CSI_SUBDEV_STBY_ON:
    vfe_dev_dbg ("CSI_SUBDEV_STBY_ON\n");
    cci_lock (sd);
    vfe_gpio_write (sd, RESET, CSI_RST_ON);
    usleep_range (1000, 1200);
    vfe_gpio_write (sd, PWDN, CSI_STBY_ON);
    usleep_range (1000, 1200);
    vfe_set_mclk (sd, OFF);
    cci_unlock (sd);
    break;
  case CSI_SUBDEV_STBY_OFF:
    vfe_dev_dbg ("CSI_SUBDEV_STBY_OFF\n");
    cci_lock (sd);
    vfe_set_mclk_freq (sd, MCLK);
    vfe_set_mclk (sd, ON);
    usleep_range (1000, 1200);
    vfe_gpio_write (sd, PWDN, CSI_STBY_OFF);
    usleep_range (1000, 1200);
    vfe_gpio_write (sd, RESET, CSI_RST_OFF);
    usleep_range (1000, 1200);
    cci_unlock (sd);
    break;
  case CSI_SUBDEV_PWR_ON:
    vfe_dev_dbg ("CSI_SUBDEV_PWR_ON\n");
    cci_lock (sd);
    vfe_gpio_set_status (sd, PWDN, 1);
    vfe_gpio_set_status (sd, RESET, 1);
    vfe_gpio_write (sd, PWDN, CSI_STBY_ON);
    vfe_gpio_write (sd, RESET, CSI_RST_ON);
    vfe_gpio_write (sd, POWER_EN, CSI_PWR_ON);
    vfe_set_pmu_channel (sd, IOVDD, ON);
    vfe_set_pmu_channel (sd, AVDD, ON);
    vfe_set_pmu_channel (sd, DVDD, ON);
    vfe_set_pmu_channel (sd, AFVDD, ON);
    usleep_range (10000, 12000);
    vfe_set_mclk_freq (sd, MCLK);
    vfe_set_mclk (sd, ON);
    vfe_gpio_write (sd, PWDN, CSI_STBY_OFF);
    usleep_range (10000, 12000);
    vfe_gpio_write (sd, RESET, CSI_RST_OFF);
    usleep_range (10000, 12000);
    cci_unlock (sd);
    break;
  case CSI_SUBDEV_PWR_OFF:
    vfe_dev_dbg ("CSI_SUBDEV_PWR_OFF\n");
    cci_lock (sd);
    vfe_gpio_write (sd, RESET, CSI_RST_ON);
    udelay (100);
    vfe_set_mclk (sd, OFF);
    udelay (10);
    vfe_gpio_write (sd, PWDN, CSI_STBY_ON);
    vfe_gpio_write (sd, POWER_EN, CSI_PWR_OFF);
    vfe_set_pmu_channel (sd, IOVDD, OFF);
    vfe_set_pmu_channel (sd, AVDD, OFF);
    vfe_set_pmu_channel (sd, DVDD, OFF);
    vfe_set_pmu_channel (sd, AFVDD, OFF);
    vfe_gpio_set_status (sd, PWDN, 0);
    vfe_gpio_set_status (sd, RESET, 0);
    cci_unlock (sd);
    break;
  default:
    return -EINVAL;
  }
  
  return 0;
}

static int sensor_reset (struct v4l2_subdev * sd, u32 val)
{
  switch (val)
  {
  case 0:
    vfe_gpio_write (sd, RESET, CSI_RST_OFF);
    usleep_range (10000, 12000);
    break;
  case 1:
    vfe_gpio_write (sd, RESET, CSI_RST_ON);
    usleep_range (10000, 12000);
    break;
  default:
    return -EINVAL;
  }
  
  return 0;
}

static int sensor_detect (struct v4l2_subdev * sd)
{
  int ret;
  unsigned short rdval = 0xffff;
  
  ret = sensor_write (sd, 0x002c, 0x7000);
  ret = sensor_write (sd, 0x002e, 0x01a4);
  if (ret < 0)
  {
    vfe_dev_err ("sensor_write err at sensor_detect!\n");
    return ret;
  }
  
  ret = sensor_read (sd, 0x0f12, &rdval);
  
  if (rdval != 0x4ec0 )
  {
    vfe_dev_err ("id read from sensor is 0x%4x,not 0x4ec0\n", rdval);
    return -ENODEV;
  }
  
  return 0;
}

static int sensor_init (struct v4l2_subdev * sd, u32 val)
{
  int ret;
  struct sensor_info * info = to_state (sd);
  
  vfe_dev_dbg ("sensor_init\n");
  
  /*Make sure it is a target sensor*/
  ret = sensor_detect (sd);
  if (ret) {
    vfe_dev_err ("chip found is not an target chip.\n");
    return ret;
  }
  
  vfe_get_standby_mode (sd, &info->stby_mode);
  
  if ( (info->stby_mode == HW_STBY || info->stby_mode == SW_STBY) \
       && info->init_first_flag == 0) {
    vfe_dev_print ("stby_mode and init_first_flag = 0\n");
    return 0;
  }
  
  info->focus_status = 0;
  info->width = 0;
  info->height = 0;
  info->brightness = 0;
  info->contrast = 0;
  info->saturation = 0;
  info->hue = 0;
  info->hflip = 0;
  info->vflip = 0;
  info->gain = 0;
  info->autogain = 1;
  info->exp = 0;
  info->autoexp = 0;
  info->autowb = 1;
  info->wb = V4L2_WHITE_BALANCE_AUTO;
  info->clrfx = V4L2_COLORFX_NONE;
  info->band_filter = V4L2_CID_POWER_LINE_FREQUENCY_50HZ;
  info->tpf.numerator = 1;
  info->tpf.denominator = 30;    /* 30fps */
  info->width = 0;
  info->height = 0;
  
  ret = sensor_write_array (sd, sensor_default_regs , ARRAY_SIZE (sensor_default_regs) );
  if (ret < 0) {
    vfe_dev_err ("write sensor_default_regs error\n");
    return ret;
  }
  
  sensor_s_band_filter (sd, V4L2_CID_POWER_LINE_FREQUENCY_50HZ);
  
  if (info->stby_mode == 0)
  { info->init_first_flag = 0; }
  
  info->preview_first_flag = 1;
  return 0;
}

static long sensor_ioctl (struct v4l2_subdev * sd, unsigned int cmd, void * arg)
{
  int ret = 0;
  return ret;
}


/*
 * Store information about the video data format.
 */
static struct sensor_format_struct {
  __u8 * desc;
  enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
  struct regval_list * regs;
  int regs_size;
  int bpp;   /* Bytes per pixel */
} sensor_formats[] = {

  {
    .desc   = "MIPI YUV422",
    .mbus_code  = V4L2_MBUS_FMT_UYVY8_16X1,
    .regs     = sensor_fmt_mipi_yuv422,
    .regs_size = ARRAY_SIZE (sensor_fmt_mipi_yuv422),
    .bpp    = 2,
  },
  
  /*{
    .desc   = "YUYV 4:2:2",
    .mbus_code  = V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
    .regs     = sensor_fmt_yuv422_yuyv,
    .regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
    .bpp    = 2,
  },
  {
    .desc   = "YVYU 4:2:2",
    .mbus_code  = V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
    .regs     = sensor_fmt_yuv422_yvyu,
    .regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
    .bpp    = 2,
  },
  {
    .desc   = "UYVY 4:2:2",
    .mbus_code  = V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
    .regs     = sensor_fmt_yuv422_uyvy,
    .regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
    .bpp    = 2,
  },
  {
    .desc   = "VYUY 4:2:2",
    .mbus_code  = V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
    .regs     = sensor_fmt_yuv422_vyuy,
    .regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
    .bpp    = 2,
  },*/
};
#define N_FMTS ARRAY_SIZE(sensor_formats)



/*
 * Then there is the issue of window sizes.  Try to capture the info here.
 */


static struct sensor_win_size sensor_win_sizes[] = {
  /* qsxga: 2592*1936 */
  {
    .width      = QSXGA_WIDTH,
    .height     = QSXGA_HEIGHT,
    .regs       = sensor_qsxga_regs,
    .hoffset    = 0,
    .voffset    = 0,
    .regs_size  = ARRAY_SIZE (sensor_qsxga_regs),
    .set_size   = NULL,
  },
  /* qxga: 2048*1536 */
  {
    .width      = QXGA_WIDTH,
    .height     = QXGA_HEIGHT,
    .hoffset    = 0,
    .voffset    = 0,
    .regs       = sensor_qxga_regs,
    .regs_size  = ARRAY_SIZE (sensor_qxga_regs),
    .set_size   = NULL,
  },
  /* 1080P */
  {
    .width      = HD1080_WIDTH,
    .height     = HD1080_HEIGHT,
    .hoffset    = 0,
    .voffset    = 0,
    .regs       = sensor_1080p_regs,
    .regs_size  = ARRAY_SIZE (sensor_1080p_regs),
    .set_size   = NULL,
  },
  
  /* 720p */
  {
    .width      = HD720_WIDTH,
    .height     = HD720_HEIGHT,
    .hoffset    = 0,
    .voffset    = 0,
    .regs       = sensor_720p_regs,
    .regs_size  = ARRAY_SIZE (sensor_720p_regs),
    .set_size   = NULL,
  },
  /* VGA */
  {
    .width      = VGA_WIDTH,
    .height     = VGA_HEIGHT,
    .hoffset    = 0,
    .voffset    = 0,
    .regs       = sensor_vga_regs,
    .regs_size  = ARRAY_SIZE (sensor_vga_regs),
    .set_size   = NULL,
  },
};

#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))




static int sensor_enum_fmt (struct v4l2_subdev * sd, unsigned index,
                            enum v4l2_mbus_pixelcode * code)
{
  if (index >= N_FMTS)
  { return -EINVAL; }
  
  *code = sensor_formats[index].mbus_code;
  return 0;
}

static int sensor_enum_size (struct v4l2_subdev * sd,
                             struct v4l2_frmsizeenum * fsize)
{
  if (fsize->index > N_WIN_SIZES - 1)
  { return -EINVAL; }
  
  fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
  fsize->discrete.width = sensor_win_sizes[fsize->index].width;
  fsize->discrete.height = sensor_win_sizes[fsize->index].height;
  
  return 0;
}


static int sensor_try_fmt_internal (struct v4l2_subdev * sd,
                                    struct v4l2_mbus_framefmt * fmt,
                                    struct sensor_format_struct ** ret_fmt,
                                    struct sensor_win_size ** ret_wsize)
{
  int index;
  struct sensor_win_size * wsize;
  
  for (index = 0; index < N_FMTS; index++)
    if (sensor_formats[index].mbus_code == fmt->code)
    { break; }
    
  if (index >= N_FMTS)
  { return -EINVAL; }
  
  if (ret_fmt != NULL)
  { *ret_fmt = sensor_formats + index; }
  
  /*
   * Fields: the sensor devices claim to be progressive.
   */
  
  fmt->field = V4L2_FIELD_NONE;
  
  /*
   * Round requested image size down to the nearest
   * we support, but not below the smallest.
   */
  for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
       wsize++)
    if (fmt->width >= wsize->width && fmt->height >= wsize->height)
    { break; }
    
  if (wsize >= sensor_win_sizes + N_WIN_SIZES)
  { wsize--; }   /* Take the smallest one */
  if (ret_wsize != NULL)
  { *ret_wsize = wsize; }
  /*
   * Note the size we'll actually handle.
   */
  fmt->width = wsize->width;
  fmt->height = wsize->height;
  fmt->reserved[0] = wsize->hoffset;
  fmt->reserved[1] = wsize->voffset;
  
  return 0;
}

static int sensor_try_fmt (struct v4l2_subdev * sd,
                           struct v4l2_mbus_framefmt * fmt)
{
  return sensor_try_fmt_internal (sd, fmt, NULL, NULL);
}

static int sensor_g_mbus_config (struct v4l2_subdev * sd,
                                 struct v4l2_mbus_config * cfg)
{
  cfg->type = V4L2_MBUS_PARALLEL;
  cfg->flags = V4L2_MBUS_MASTER | VREF_POL | HREF_POL | CLK_POL ;
  
  return 0;
}

/*
 * Set a format.
 */
static int sensor_s_fmt (struct v4l2_subdev * sd,
                         struct v4l2_mbus_framefmt * fmt)
{
  int ret;
  struct sensor_format_struct * sensor_fmt;
  struct sensor_win_size * wsize;
  struct sensor_info * info = to_state (sd);
  
  vfe_dev_dbg ("sensor_s_fmt\n");
  

  ret = sensor_try_fmt_internal (sd, fmt, &sensor_fmt, &wsize);
  if (ret)
  { return ret; }
  
  if (info->fmt == sensor_fmt && info->width == wsize->width && info->height == wsize->height)
  {
    vfe_dev_print ("format and size remain the same\n");
    goto update;
  }
  
  if (info->capture_mode == V4L2_MODE_VIDEO ||
      info->capture_mode == V4L2_MODE_PREVIEW)
  {
  }
  else
    if (info->capture_mode == V4L2_MODE_IMAGE)
    {
      ret = sensor_set_exposure (sd);
      if (ret < 0)
      {
        vfe_dev_err ("sensor_set_exposure err !\n");
        return ret;
      }
    }
    
  ret = sensor_write_array (sd, sensor_fmt->regs , sensor_fmt->regs_size);
  if (ret < 0)
  { return ret; }
  
  ret = 0;
  if (wsize->regs)
  { LOG_ERR_RET (sensor_write_array (sd, wsize->regs , wsize->regs_size) ); }
  
  if (wsize->set_size)
  { LOG_ERR_RET (wsize->set_size (sd) ); }
  
  if (info->capture_mode == V4L2_MODE_VIDEO || info->capture_mode == V4L2_MODE_PREVIEW)
  {
  }
  
update:
  info->fmt = sensor_fmt;
  info->width = wsize->width;
  info->height = wsize->height;
  
  vfe_dev_print ("s_fmt set width = %d, height = %d\n", wsize->width, wsize->height);
  

  return 0;
}


/*
 * Implement G/S_PARM.  There is a "high quality" mode we could try
 * to do someday; for now, we just do the frame rate tweak.
 */
static int sensor_g_parm (struct v4l2_subdev * sd, struct v4l2_streamparm * parms)
{
  struct v4l2_captureparm * cp = &parms->parm.capture;
  struct sensor_info * info = to_state (sd);
  
  if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
  { return -EINVAL; }
  
  memset (cp, 0, sizeof (struct v4l2_captureparm) );
  cp->capability = V4L2_CAP_TIMEPERFRAME;
  cp->capturemode = info->capture_mode;
  
  cp->timeperframe.numerator = info->tpf.numerator;
  cp->timeperframe.denominator = info->tpf.denominator;
  
  return 0;
}

static int sensor_s_parm (struct v4l2_subdev * sd, struct v4l2_streamparm * parms)
{
  struct v4l2_captureparm * cp = &parms->parm.capture;
  struct v4l2_fract * tpf = &cp->timeperframe;
  struct sensor_info * info = to_state (sd);
  unsigned char div;
  
  vfe_dev_dbg ("sensor_s_parm\n");
  
  if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
    vfe_dev_dbg ("parms->type!=V4L2_BUF_TYPE_VIDEO_CAPTURE\n");
    return -EINVAL;
  }
  
  if (info->tpf.numerator == 0) {
    vfe_dev_dbg ("info->tpf.numerator == 0\n");
    return -EINVAL;
  }
  
  info->capture_mode = cp->capturemode;
  
  if (info->capture_mode == V4L2_MODE_IMAGE) {
    vfe_dev_dbg ("capture mode is not video mode,can not set frame rate!\n");
    return 0;
  }
  
  if (tpf->numerator == 0 || tpf->denominator == 0) {
    tpf->numerator = 1;
    tpf->denominator = SENSOR_FRAME_RATE;/* Reset to full rate */
    vfe_dev_err ("sensor frame rate reset to full rate!\n");
  }
  
  div = SENSOR_FRAME_RATE / (tpf->denominator / tpf->numerator);
  if (div > 15 || div == 0)
  {
    vfe_dev_print ("SENSOR_FRAME_RATE=%d\n", SENSOR_FRAME_RATE);
    vfe_dev_print ("tpf->denominator=%d\n", tpf->denominator);
    vfe_dev_print ("tpf->numerator=%d\n", tpf->numerator);
    return -EINVAL;
  }
  
  vfe_dev_dbg ("set frame rate %d\n", tpf->denominator / tpf->numerator);
  
  info->tpf.denominator = SENSOR_FRAME_RATE;
  info->tpf.numerator = div;
  
  if (info->tpf.denominator / info->tpf.numerator < 30)
  { info->low_speed = 1; }
  
  return 0;
}


static int sensor_queryctrl (struct v4l2_subdev * sd,
                             struct v4l2_queryctrl * qc)
{
  /* Fill in min, max, step and default value for these controls. */
  /* see include/linux/videodev2.h for details */
  switch (qc->id) {
  case V4L2_CID_VFLIP:
  case V4L2_CID_HFLIP:
    return v4l2_ctrl_query_fill (qc, 0, 1, 1, 0);
  case V4L2_CID_EXPOSURE:
  case V4L2_CID_AUTO_EXPOSURE_BIAS:
    return v4l2_ctrl_query_fill (qc, -4, 4, 1, 0);
  case V4L2_CID_EXPOSURE_AUTO:
    return v4l2_ctrl_query_fill (qc, 0, 1, 1, 0);
  case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
    return v4l2_ctrl_query_fill (qc, 0, 9, 1, 1);
  case V4L2_CID_AUTO_WHITE_BALANCE:
    return v4l2_ctrl_query_fill (qc, 0, 1, 1, 1);
  case V4L2_CID_COLORFX:
    return v4l2_ctrl_query_fill (qc, 0, 15, 1, 0);
  case V4L2_CID_FLASH_LED_MODE:
    return v4l2_ctrl_query_fill (qc, 0, 4, 1, 0);
    
  case V4L2_CID_AUTO_FOCUS_INIT:
  case V4L2_CID_AUTO_FOCUS_RELEASE:
  case V4L2_CID_AUTO_FOCUS_START:
  case V4L2_CID_AUTO_FOCUS_STOP:
  case V4L2_CID_AUTO_FOCUS_STATUS:
    return v4l2_ctrl_query_fill (qc, 0, 0, 0, 0);
  case V4L2_CID_FOCUS_AUTO:
    return v4l2_ctrl_query_fill (qc, 0, 1, 1, 0);
  case V4L2_CID_AUTO_EXPOSURE_WIN_NUM:
    return v4l2_ctrl_query_fill (qc, 0, 1, 1, 0);
  case V4L2_CID_AUTO_FOCUS_WIN_NUM:
    return v4l2_ctrl_query_fill (qc, 0, 1, 1, 0);
  }
  return -EINVAL;
}

static int sensor_g_ctrl (struct v4l2_subdev * sd, struct v4l2_control * ctrl)
{
  switch (ctrl->id) {
  case V4L2_CID_BRIGHTNESS:
    return sensor_g_brightness (sd, &ctrl->value);
  case V4L2_CID_CONTRAST:
    return sensor_g_contrast (sd, &ctrl->value);
  case V4L2_CID_SATURATION:
    return sensor_g_saturation (sd, &ctrl->value);
  case V4L2_CID_HUE:
    return sensor_g_hue (sd, &ctrl->value);
  case V4L2_CID_VFLIP:
    return sensor_g_vflip (sd, &ctrl->value);
  case V4L2_CID_HFLIP:
    return sensor_g_hflip (sd, &ctrl->value);
  case V4L2_CID_GAIN:
    return sensor_g_gain (sd, &ctrl->value);
  case V4L2_CID_AUTOGAIN:
    return sensor_g_autogain (sd, &ctrl->value);
  case V4L2_CID_EXPOSURE:
  case V4L2_CID_AUTO_EXPOSURE_BIAS:
    return sensor_g_exp_bias (sd, &ctrl->value);
  case V4L2_CID_EXPOSURE_AUTO:
    return sensor_g_autoexp (sd, &ctrl->value);
  case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
    return sensor_g_wb (sd, &ctrl->value);
  case V4L2_CID_AUTO_WHITE_BALANCE:
    return sensor_g_autowb (sd, &ctrl->value);
  case V4L2_CID_COLORFX:
    return sensor_g_colorfx (sd, &ctrl->value);
  case V4L2_CID_FLASH_LED_MODE:
    return sensor_g_flash_mode (sd, &ctrl->value);
  case V4L2_CID_POWER_LINE_FREQUENCY:
    return sensor_g_band_filter (sd, &ctrl->value);
    
  case V4L2_CID_AUTO_FOCUS_STATUS:
    return sensor_g_af_status (sd);
  case V4L2_CID_AUTO_FOCUS_WIN_NUM:
    ctrl->value = 1;
    return 0;
  case V4L2_CID_AUTO_EXPOSURE_WIN_NUM:
    ctrl->value = 1;
    return 0;
  }
  return -EINVAL;
}

static int sensor_s_ctrl (struct v4l2_subdev * sd, struct v4l2_control * ctrl)
{
  struct v4l2_queryctrl qc;
  int ret;
  
  qc.id = ctrl->id;
  ret = sensor_queryctrl (sd, &qc);
  if (ret < 0) {
    return ret;
  }
  
  if (qc.type == V4L2_CTRL_TYPE_MENU ||
      qc.type == V4L2_CTRL_TYPE_INTEGER ||
      qc.type == V4L2_CTRL_TYPE_BOOLEAN)
  {
    if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
      return -ERANGE;
    }
  }
  
  switch (ctrl->id) {
  case V4L2_CID_BRIGHTNESS:
    return sensor_s_brightness (sd, ctrl->value);
  case V4L2_CID_CONTRAST:
    return sensor_s_contrast (sd, ctrl->value);
  case V4L2_CID_SATURATION:
    return sensor_s_saturation (sd, ctrl->value);
  case V4L2_CID_HUE:
    return sensor_s_hue (sd, ctrl->value);
  case V4L2_CID_VFLIP:
    return sensor_s_vflip (sd, ctrl->value);
  case V4L2_CID_HFLIP:
    return sensor_s_hflip (sd, ctrl->value);
  case V4L2_CID_GAIN:
    return sensor_s_gain (sd, ctrl->value);
  case V4L2_CID_AUTOGAIN:
    return sensor_s_autogain (sd, ctrl->value);
  case V4L2_CID_EXPOSURE:
  case V4L2_CID_AUTO_EXPOSURE_BIAS:
    return sensor_s_exp_bias (sd, ctrl->value);
  case V4L2_CID_EXPOSURE_AUTO:
    return sensor_s_autoexp (sd,
                             (enum v4l2_exposure_auto_type) ctrl->value);
  case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
    return sensor_s_wb (sd,
                        (enum v4l2_auto_n_preset_white_balance) ctrl->value);
  case V4L2_CID_AUTO_WHITE_BALANCE:
    return sensor_s_autowb (sd, ctrl->value);
  case V4L2_CID_COLORFX:
    return sensor_s_colorfx (sd,
                             (enum v4l2_colorfx) ctrl->value);
  case V4L2_CID_FLASH_LED_MODE:
    return sensor_s_flash_mode (sd,
                                (enum v4l2_flash_led_mode) ctrl->value);
  case V4L2_CID_POWER_LINE_FREQUENCY:
    return sensor_s_band_filter (sd,
                                 (enum v4l2_power_line_frequency) ctrl->value);
                                 
  case V4L2_CID_AUTO_FOCUS_INIT:
    return sensor_s_init_af (sd);
  case V4L2_CID_AUTO_FOCUS_RELEASE:
    return sensor_s_release_af (sd);
  case V4L2_CID_AUTO_FOCUS_START:
    return sensor_s_single_af (sd);
  case V4L2_CID_AUTO_FOCUS_STOP:
    return sensor_s_pause_af (sd);
  case V4L2_CID_FOCUS_AUTO:
    return sensor_s_continueous_af (sd, ctrl->value);
  case V4L2_CID_AUTO_FOCUS_WIN_NUM:
    return sensor_s_af_zone (sd, (struct v4l2_win_coordinate *) (ctrl->user_pt) );
  case V4L2_CID_AUTO_EXPOSURE_WIN_NUM:
    return 0;
  }
  return -EINVAL;
}


static int sensor_g_chip_ident (struct v4l2_subdev * sd,
                                struct v4l2_dbg_chip_ident * chip)
{
  struct i2c_client * client = v4l2_get_subdevdata (sd);
  
  return v4l2_chip_ident_i2c_client (client, chip, V4L2_IDENT_SENSOR, 0);
}


/* ----------------------------------------------------------------------- */

static const struct v4l2_subdev_core_ops sensor_core_ops = {
  .g_chip_ident = sensor_g_chip_ident,
  .g_ctrl = sensor_g_ctrl,
  .s_ctrl = sensor_s_ctrl,
  .queryctrl = sensor_queryctrl,
  .reset = sensor_reset,
  .init = sensor_init,
  .s_power = sensor_power,
  .ioctl = sensor_ioctl,
};

static const struct v4l2_subdev_video_ops sensor_video_ops = {
  .enum_mbus_fmt = sensor_enum_fmt,
  .enum_framesizes = sensor_enum_size,
  .try_mbus_fmt = sensor_try_fmt,
  .s_mbus_fmt = sensor_s_fmt,
  .s_parm = sensor_s_parm,
  .g_parm = sensor_g_parm,
  .g_mbus_config = sensor_g_mbus_config,
};

static const struct v4l2_subdev_ops sensor_ops = {
  .core = &sensor_core_ops,
  .video = &sensor_video_ops,
};


/* ----------------------------------------------------------------------- */
static struct cci_driver cci_drv = {
  .name = SENSOR_NAME,
};
static int sensor_probe (struct i2c_client * client,
                         const struct i2c_device_id * id)
{
  struct v4l2_subdev * sd;
  struct sensor_info * info;

  info = kzalloc (sizeof (struct sensor_info), GFP_KERNEL);
  if (info == NULL)
  { return -ENOMEM; }
  sd = &info->sd;
  cci_dev_probe_helper (sd, client, &sensor_ops, &cci_drv);
  
  info->fmt = &sensor_formats[0];
  info->af_first_flag = 1;
  info->init_first_flag = 1;
  info->auto_focus = 0;
  
  return 0;
}


static int sensor_remove (struct i2c_client * client)
{
  struct v4l2_subdev * sd;
  
  sd = cci_dev_remove_helper (client, &cci_drv);
  kfree (to_state (sd) );
  return 0;
}

static const struct i2c_device_id sensor_id[] = {
  { SENSOR_NAME, 0 },
  { }
};
MODULE_DEVICE_TABLE (i2c, sensor_id);

static struct i2c_driver sensor_driver = {
  .driver = {
    .owner = THIS_MODULE,
    .name = SENSOR_NAME,
  },
  .probe = sensor_probe,
  .remove = sensor_remove,
  .id_table = sensor_id,
};
static __init int init_sensor (void)
{
  return cci_dev_init_helper (&sensor_driver);
}

static __exit void exit_sensor (void)
{
  cci_dev_exit_helper (&sensor_driver);
}

module_init (init_sensor);
module_exit (exit_sensor);


